         TITLE 'Test MP instruction'
***********************************************************************
         MACRO
         XDUMP
         STMG  0,15,XREGS&SYSNDX   Save registers
         IPM   0                   Get CC and program mask
         ST    0,XCCPM&SYSNDX      Save CC and program mask
         CNOP  0,4                 Align on fullword
         BAS   R1,*+8*16+4+4       Branch around parm list
XREGS&SYSNDX   DS    32F           Registers
XCCPM&SYSNDX   DS    F             Condition code and program mask
         LARL  15,DUMPREGS         Dump routine
         BASR  14,15               Dump the registers and CC, pgm mask
         LARL  15,XREGS&SYSNDX     Saved registers and CC, pgm mask
         L     0,128(,15)          Saved CC and program mask
         SPM   0                   Restore CC and program mask
         LMG   0,15,0(15)          Restore registers
         MEND
***********************************************************************
         EJECT ,
***********************************************************************
*
* Module: TMP
*
* Function: Test MP instruction.
*
* Input:
*
*   R1 --> word --> halfword || EBCDIC text (standard PARM=value)
*
*      Allowable values: A print all data
*                        S print summary data; default
*
***********************************************************************
*
TMP      CSECT
TMP      AMODE 31
TMP      RMODE 31
         STM   R14,R12,12(R13)     Save caller's registers
         LLGTR R15,R15             Insure bit 32 is zero
         LR    R12,R15             R12 = base register
         USING TMP,R12             Establish addressability
         LARL  R11,Data            Data area
         Using Data,R11            Overlay data area forever
*
         LA    R14,SA              Usable save area
         ST    R14,8(,R13)         Chain
         ST    R13,4(,R14)               save areas
         LR    R13,R14             R13 --> current save area
*
***********************************************************************
*        Get PARM= data and initialize test counters
***********************************************************************
*
         BAS   R14,GetParm         Get PARM= info
*
         XC    MP01ST,MP01ST       Zero all test counts
         MVC   MP02ST,MP01ST
         MVC   MP02ST,MP01ST
         MVC   MP03ST,MP01ST
         MVC   MP04ST,MP01ST
         MVC   MP05ST,MP01ST
*
***********************************************************************
*         MP op1,op2 tests
*
*         1. Product is zero. No errors.
*         2. Product is non-zero. No errors.
*         3. First operand does not have enough leading zeros. S0C7.
*         4. Invalid data in one or both operands. S0C7.
*         5. Op2 too long or op2 len > op1 len. S0C6.
***********************************************************************
*
         WTO   MF=(E,WTOStart)      Start message
*
         LARL  R15,T01              First test
         BASR  R14,R15              Perform test
*
         LARL  R15,T02              Second test
         BASR  R14,R15              Perform test
*
         LARL  R15,T03              Third test
         BASR  R14,R15              Perform test
*
         LARL  R15,T04              Fourth test
         BASR  R14,R15              Perform test
*
         LARL  R15,T05              Fifth test
         BASR  R14,R15              Perform test
*
***********************************************************************
*        Print totals
***********************************************************************
*
         LARL  R15,PrtTot          Print totals for all tests
         BASR  R14,R15
*
***********************************************************************
*        All done
***********************************************************************
*
         WTO   MF=(E,WTOEnd)       End message
*
         L     R13,4(,R13)         Caller's save area                                                               
         LM    R14,R12,12(R13)     Restore caller's registers   
         SR    R15,R15             Set return code to zero      
         BR    R14                 Return to caller
*
***********************************************************************
*
* Routine: GetParm
*
*        Get information from PARM=xxx
*
***********************************************************************
*
GetParm  DS    0H
         STM   R14,R12,12(R13)     Save caller's registers
*
*        Only two values allowed:
*        PARM=A  print all data; includes summary data
*        PARM=S  print summary data
*
*        Default is PARM=S
*
         MVI   WRptType,C'S'       Default is print summary
*
         L     R2,0(,R1)           R2 --> PARM= info
         LH    R3,0(,R2)           Length of info
         CHI   R3,1                Should only be one value
         BNE   GPDone              Use default if not
         CLI   2(R2),C'A'          Print all data?
         BNE   GPDone              No; use default
         MVI   WRptType,C'A'       Yes; set for all data
GPDone   DS    0H
         LM    R14,R12,12(R13)     Restore caller's registers
         BR    R14                 Return to caller             
*                                                               
         LTORG                                                  
*
         DROP  R11,R12             End addressability
*
         TITLE 'Test Subroutines'
*
***********************************************************************
*
* Routine: T01
*
*        MP   op1,op2  No error; product is zero.
*
*----------------------------------------------------------------------
*
* WARNING  WARNING  WARNING  WARNING  WARNING  WARNING  WARNING WARNING
*
* The pz390 code does not set the sign of the product correctly when
* the product is zero! For this case, the sign of the product is
* set to C hex.
*
* The Principles of Operation says that "the sign of the product is
* determined by the rules of algebra from the multiplier and
* multiplicand signs, even if one or both operands are zeros."
*
* For example,
*
*     001D * 0C = 000D = 002C * 0D and
*     000D * 0C = 000D = 000C * 0D.
*
* The pz390 code computes 000C for all four products.
*
* Due to this error in pz390, half (96) of the test cases will
* fail due to the actual product not matching the expected product.
*
* To ensure that the 96 errors are, indeed, as described here, run
* this program with PARM('A') and look at the output. Search for
* "1*" (all errors have an asterick in column 2 of the first line
* of output). You will see something like
*
*   1*                           00000B * 0A
*              AnsAct 00000C                            AnsExp 00000D
*              CCAct 3  CCExp 3
*
* The first line shows the multiplication being tested. Here it
* is 0- * 0+. The second line shows the actual answer, 0+, and the
* expected answer, 0-. The third line shows the actual and expected
* condition codes. Note that the actual and expected answers differ
* as described above.
*
* All 96 occurrences of "1*" are similar.
*
* If you want to change the 96 negative expected results to positive
* so that the test program does not have any errors, do a global
* change of "MP1EVN)" to "MP1EVP)".
*
* A future RPI will address this issue.
*
*----------------------------------------------------------------------
*
*        All tests should complete with the condition code unchanged
*        and have sign nibble set appropriately.
*
*        Four groups of tests. Each group corresponds to a row in the
*        following table:
*
*            op1 length    op2 length
*            ----------    ----------
*                 3             1
*                 7             3
*                11             5
*                16             8
*
*            operand 1 sign nibbles are A,B,C,D
*            operand 2 sign nibbles are A,B,C,D
*        
*        Each group has 4 op1 zero values, 4 op1 non-zero values,
*        4 op2 zero values, and 4 op2 non-zero values, for a total of
*
*          4 * 8 = 32
*        + 8 * 4 = 32
*          ----------
*                  64      
*                 -16 = 4 * 4 = number of cases where product not zero
*                  --
*                  48
*
*        test cases.
*
*        Total number of test cases = 4 * 48 = 192.
*
***********************************************************************
*
*        Result negative zero
*
*        op1 <= 0; len 3, 7, 11, 16; sign nibbles B, D
*        op2 >= 0; len 1, 3, 5, 8; sign nibbles A, C
*
*        op1 >= 0; len 3, 7, 11, 16; sign nibbles A, C
*        op2 <= 0; len 1, 3, 5, 8; sign nibbles B, D
*
*        All tests should complete with unchanged CC and have
*        sign nibble D.
*
***********************************************************************
*
*        Result positive zero
*
*        op1 <= 0; len 3, 7, 11, 16; sign nibbles B, D
*        op2 <= 0; len 1, 3, 5, 8; sign nibbles B, D
*
*        op1 >= 0; len 3, 7, 11, 16; sign nibbles A, C
*        op2 >= 0; len 1, 3, 5, 8; sign nibbles A, C
*
*        All tests should complete with unchanged CC and have
*        sign nibble C.
*   
***********************************************************************
*
*        Total number of failures, total number of successes,
*        stored in common storage fields MP01#F, MP01#S,
*        respectively.
*
***********************************************************************
*
         USING Data,R11            R11 --> data always
T01      DS    0H
         STM   R14,R12,12(R13)     Save caller's registers
         L     R13,8(,R13)         Next save area
         LR    R12,R15             R12 = base register
         USING T01,R12             Establish addressability
*
         LM    R1,R3,MP1PLP        R1 --> 1st parameter list
*                                  R2  =  len one parameter list
*                                  R3 --> last parameter list
*
         SR    R9,R9               R9 = number of tests that fail
         LR    R10,R9              R10 = number of tests that succeed
*
         MVI   WT#,C'1'            Test number for print routine
*
         MVI   WExpABCC,X'FF'      No abends are expected
*
T01100   DS    0H
         BAS   R14,T01Mul          Perform one multiply
         LTR   R15,R15             Test successful?
         BZ    T01200              Yes; count success
         AHI   R9,1                No; count failure
         B     T01300              Continue
T01200   DS    0H
         AHI   R10,1               Count success
T01300   DS    0H
         LARL  R15,PrtRes          Print routine
         BASR  R14,R15             Print results
         BXLE  R1,R2,T01100        Process all parameter lists
*
         STM   R9,R10,MP01ST       Save # failures, # successes
*
         L     R13,4(,R13)         Caller's save area
         LM    R14,R12,12(R13)     Restore caller's registers
         BR    R14                 Return to caller
*        
***********************************************************************
*
* Routine: T01Mul
*
*        Perform one MP test
*
*        Input:
*
*            R1 --> parameter list
*                   +0 --> value for op1; 1st byte len code
*                   +4 --> value for op2; 1st byte len code
*                   +8 --> expected product; 16 bytes; no len code
*                   +C  =  expected CC (always 3)
*
*        Output:
*
*            WErr    report error indicator; ' ' no error; '*' error
*
*            WCC     condition code after instruction executed
*                    X'FF' in leftmost byte if instruction not executed
*
*            WResult set to result; left-justified in 16-byte field
*                    X'FF' in leftmost byte if instruction not executed
*
*        Return code: 0 test succeeded
*                     4 test failed
*                     16 invalid (op1len,op2len) pair
*
***********************************************************************
*
T01Mul   DS    0H
         STM   R14,R12,12(R13)     Save caller's registers
         L     R13,8(,R13)         Next save area
*
         LM    R2,R4,0(R1)         R2 --> op1 value
*                                  R3 --> op2 value
*                                  R4 --> expected product; 16 bytes
         L     R0,12(,R1)          R0  =  expected CC
*
         MVI   WErr,C' '           No failure
         MVI   WCC,X'FF'           No CC; instruction not executed
         MVI   WResult,X'FF'       No result; instruction not executed
*
         SR    R5,R5               Prepare to get op1 len code
         SR    R6,R6               Prepare to get op2 len code
         IC    R5,0(,R2)           op1 len code; 0 - 15
         SLL   R5,4                Move left one nibble
         IC    R6,0(,R3)           op2 len code; 0 - 15
         OR    R5,R6               R5 = op1LC || op2LC
         IC    R5,T01TT(R5)        Get branch table index
         SLL   R5,2                Convert to offset
         TM    *,X'91'             Set CC 3
         B     T01MulBT(R5)        Branch to appropriate code
T01MulBT DS    0H
         B     T01MulER            Skip; invalid (op1 len, op2 len)
         B     T01Mul_3_1          op1 len 3, op2 len 1
         B     T01Mul_7_3          op1 len 7, op2 len 5
         B     T01Mul_11_5         op1 len 10, op2 len 4
         B     T01Mul_16_8         op1 len 16, op2 len 7
*
T01Mul_3_1     DS    0H
         MVC   W1L3,1(R2)          Copy op1 value to work
         MVC   W2L1,1(R3)          Copy op2 value to work
         LA    R5,W1L3             R5 --> result
         LA    R6,L'W1L3-1         R6  =  len code of result
         MP    W1L3,W2L1           Do the multiplication
         B     T01MulCR            Check the result
T01Mul_7_3     DS    0H
         MVC   W1L7,1(R2)          Copy op1 value to work
         MVC   W2L3,1(R3)          Copy op2 value to work
         LA    R5,W1L7             R5 --> result
         LA    R6,L'W1L7-1         R6  =  len code of result
         MP    W1L7,W2L3           Do the multiplication
         B     T01MulCR            Check the result
T01Mul_11_5    DS    0H
         MVC   W1L11,1(R2)         Copy op1 value to work
         MVC   W2L5,1(R3)          Copy op2 value to work
         LA    R5,W1L1             R5 --> result
         LA    R6,L'W1L1-1         R6  =  len code of result
         MP    W1L11,W2L5          Do the multiplication
         B     T01MulCR            Check the result
T01Mul_16_8    DS    0H
         MVC   W1L16,1(R2)         Copy op1 value to work
         MVC   W2L8,1(R3)          Copy op2 value to work
         LA    R5,W1L16            R5 --> result
         LA    R6,L'W1L16-1        R6  =  len code of result
         MP    W1L16,W2L8          Do the multiplication
         B     T01MulCR            Check the result
*
T01MulER DS    0H
         LA    R15,16              Invalid op1,op2 length pair
         B     T01MulDone          Done
T01MulCR DS    0H
         IPM   R15                 Get CC, Pgm Mask
         SRL   R15,28              Isolate CC
         ST    R15,WCC             Save in print work area
         EX    R6,T01MVC           Copy result to print work area
         BAS   R14,T01CkRs         Check result; sets R15
T01MulDone     DS    0H
         LTR   R15,R15             Error or check failed?
         BZ    T01MulExit          No; just exit
         MVI   WErr,C'*'           Yes; set error indicator
T01MulExit     DS    0H
         L     R13,4(,R13)         Caller's save area
         L     R14,12(,R13)        Restore caller's registers
         LM    R0,R12,20(R13)      ... except for R15
         BR    R14                 Return to caller
*
T01MVC   MVC   WResult(*-*),0(R5)  Copy result to print work area
*
***********************************************************************
*
* Routine: T01CkRs
*
*        Check result
*
*        Input:
*
*          R0  =  expected CC
*          R15 =  actual CC
*          R5 --> op1
*          R6  =  len code of op1
*          R4 --> 16 byte expected result
*
*        Return code: 0 Test succeeded
*                     4 Test failed
*
***********************************************************************
*
T01CkRs  DS    0H
         CR    R15,R0              Actual CC = expected CC?
         BNE   T01F                Failure if not equal
         LA    R15,15(,R4)         Last byte of expected result
         SR    R15,R6              R15 --> op1 expected result
         EX    R6,T01CLC           op1 : expected
         BE    T01S                Success if equal
T01F     DS    0H
         LA    R15,4               Test failed
         B     T01D                Done
T01S     DS    0H
         SR    R15,R15             Test succeeded
*NSI     B     T01D                Done
T01D     DS    0H
         BR    R14                 Return
*
T01CLC   CLC   0(*-*,R5),0(R15)    op1 : expected result
*
***********************************************************************
*        Convert byte X'op1LC || op2LC' to branch table index
***********************************************************************
T01TT    DC    256AL1(0)           Translate table
         ORG   T01TT+X'20'         op1 len code 2, op2 len code 0
         DC    AL1(1)
         ORG   T01TT+X'62'         op1 len code 6, op2 len code 2
         DC    AL1(2)
         ORG   T01TT+X'A4'         op1 len code 10, op2 len code 4
         DC    AL1(3)
         ORG   T01TT+X'F7'         op1 len code 15, op2 len code 7
         DC    AL1(4)
         ORG   ,
*
         LTORG
*
***********************************************************************
*        Parameter lists for all tests
***********************************************************************
*
MP1PLP   DC    A(MP1PLP1,16,MP1PLPN)       1st plist, len 1, last plist
*
*        Note: one of op1, op2 must be zero for all these tests!
*
MP1PLP1  DS    0A                          first parameter list
***********************************************************************
*        negative (zero) * negative (zero) = positive zero
***********************************************************************
*
*        op1 len 3 * op2 len 1
*
         DC    A(MP1_OP1_L3_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L1_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L1_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L1_V_N_3)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L1_V_N_4)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L1_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L1_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L1_V_N_3)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L1_V_N_4)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_3)         op1 value nz-
         DC    A(MP1_OP2_L1_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_3)         op1 value nz-
         DC    A(MP1_OP2_L1_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_4)         op1 value nz-
         DC    A(MP1_OP2_L1_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_4)         op1 value nz-
         DC    A(MP1_OP2_L1_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 7 * op2 len 3
*
         DC    A(MP1_OP1_L7_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L3_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L3_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L3_V_N_3)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L3_V_N_4)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L3_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L3_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L3_V_N_3)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L3_V_N_4)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_3)         op1 value nz-
         DC    A(MP1_OP2_L3_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_3)         op1 value nz-
         DC    A(MP1_OP2_L3_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_4)         op1 value nz-
         DC    A(MP1_OP2_L3_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_4)         op1 value nz-
         DC    A(MP1_OP2_L3_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 11 * op2 len 5
*
         DC    A(MP1_OP1_L11_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L5_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L5_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L5_V_N_3)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L5_V_N_4)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L5_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L5_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L5_V_N_3)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L5_V_N_4)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_3)        op1 value nz-
         DC    A(MP1_OP2_L5_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_3)        op1 value nz-
         DC    A(MP1_OP2_L5_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_4)        op1 value nz-
         DC    A(MP1_OP2_L5_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_4)        op1 value nz-
         DC    A(MP1_OP2_L5_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 16 * op2 len 8
*
         DC    A(MP1_OP1_L16_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L8_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L8_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L8_V_N_3)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L8_V_N_4)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L8_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L8_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L8_V_N_3)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L8_V_N_4)         op2 value nz-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_3)        op1 value nz-
         DC    A(MP1_OP2_L8_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_3)        op1 value nz-
         DC    A(MP1_OP2_L8_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_4)        op1 value nz-
         DC    A(MP1_OP2_L8_V_N_1)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_4)        op1 value nz-
         DC    A(MP1_OP2_L8_V_N_2)         op2 value 0-
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*        negative (zero) * positive (zero) = negative zero
***********************************************************************
*
*        op1 len 3 * op2 len 1
*
         DC    A(MP1_OP1_L3_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L1_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L1_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L1_V_P_3)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L1_V_P_4)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L1_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L1_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L1_V_P_3)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L1_V_P_4)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_3)         op1 value nz-
         DC    A(MP1_OP2_L1_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_3)         op1 value nz-
         DC    A(MP1_OP2_L1_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_4)         op1 value nz-
         DC    A(MP1_OP2_L1_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_N_4)         op1 value nz-
         DC    A(MP1_OP2_L1_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 7 * op2 len 3
*
         DC    A(MP1_OP1_L7_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L3_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L3_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L3_V_P_3)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_1)         op1 value 0-
         DC    A(MP1_OP2_L3_V_P_4)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L3_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L3_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L3_V_P_3)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_2)         op1 value 0-
         DC    A(MP1_OP2_L3_V_P_4)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_3)         op1 value nz-
         DC    A(MP1_OP2_L3_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_3)         op1 value nz-
         DC    A(MP1_OP2_L3_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_4)         op1 value nz-
         DC    A(MP1_OP2_L3_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_N_4)         op1 value nz-
         DC    A(MP1_OP2_L3_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 11 * op2 len 5
*
         DC    A(MP1_OP1_L11_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L5_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L5_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L5_V_P_3)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L5_V_P_4)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L5_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L5_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L5_V_P_3)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L5_V_P_4)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_3)        op1 value nz-
         DC    A(MP1_OP2_L5_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_3)        op1 value nz-
         DC    A(MP1_OP2_L5_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_4)        op1 value nz-
         DC    A(MP1_OP2_L5_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_N_4)        op1 value nz-
         DC    A(MP1_OP2_L5_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 16 * op2 len 8
*
         DC    A(MP1_OP1_L16_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L8_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L8_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L8_V_P_3)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_1)        op1 value 0-
         DC    A(MP1_OP2_L8_V_P_4)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L8_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L8_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L8_V_P_3)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_2)        op1 value 0-
         DC    A(MP1_OP2_L8_V_P_4)         op2 value nz+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_3)        op1 value nz-
         DC    A(MP1_OP2_L8_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_3)        op1 value nz-
         DC    A(MP1_OP2_L8_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_4)        op1 value nz-
         DC    A(MP1_OP2_L8_V_P_1)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_N_4)        op1 value nz-
         DC    A(MP1_OP2_L8_V_P_2)         op2 value 0+
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*        positive (zero) * negative (zero) = negative zero
***********************************************************************
*
*        op1 len 3 * op2 len 1
*
         DC    A(MP1_OP1_L3_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L1_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L1_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L1_V_N_3)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L1_V_N_4)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L1_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L1_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L1_V_N_3)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L1_V_N_4)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_3)         op1 value nz+
         DC    A(MP1_OP2_L1_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_3)         op1 value nz+
         DC    A(MP1_OP2_L1_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_4)         op1 value nz+
         DC    A(MP1_OP2_L1_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_4)         op1 value nz+
         DC    A(MP1_OP2_L1_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 7 * op2 len 3
*
         DC    A(MP1_OP1_L7_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L3_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L3_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L3_V_N_3)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L3_V_N_4)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L3_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L3_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L3_V_N_3)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L3_V_N_4)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_3)         op1 value nz+
         DC    A(MP1_OP2_L3_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_3)         op1 value nz+
         DC    A(MP1_OP2_L3_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_4)         op1 value nz+
         DC    A(MP1_OP2_L3_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_4)         op1 value nz+
         DC    A(MP1_OP2_L3_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 11 * op2 len 5
*
         DC    A(MP1_OP1_L11_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L5_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L5_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L5_V_N_3)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L5_V_N_4)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L5_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L5_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L5_V_N_3)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L5_V_N_4)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_3)        op1 value nz+
         DC    A(MP1_OP2_L5_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_3)        op1 value nz+
         DC    A(MP1_OP2_L5_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_4)        op1 value nz+
         DC    A(MP1_OP2_L5_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_4)        op1 value nz+
         DC    A(MP1_OP2_L5_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 16 * op2 len 8
*
         DC    A(MP1_OP1_L16_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L8_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L8_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L8_V_N_3)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L8_V_N_4)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L8_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L8_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L8_V_N_3)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L8_V_N_4)         op2 value nz-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_3)        op1 value nz+
         DC    A(MP1_OP2_L8_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_3)        op1 value nz+
         DC    A(MP1_OP2_L8_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_4)        op1 value nz+
         DC    A(MP1_OP2_L8_V_N_1)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_4)        op1 value nz+
         DC    A(MP1_OP2_L8_V_N_2)         op2 value 0-
         DC    A(MP1EVZN)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*        positive (zero) * positive (zero) = positive (zero)
***********************************************************************
*
*        op1 len 3 * op2 len 1
*
         DC    A(MP1_OP1_L3_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L1_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L1_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L1_V_P_3)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L1_V_P_4)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L1_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L1_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L1_V_P_3)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L1_V_P_4)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_3)         op1 value nz+
         DC    A(MP1_OP2_L1_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_3)         op1 value nz+
         DC    A(MP1_OP2_L1_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_4)         op1 value nz+
         DC    A(MP1_OP2_L1_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L3_V_P_4)         op1 value nz+
         DC    A(MP1_OP2_L1_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 7 * op2 len 3
*
         DC    A(MP1_OP1_L7_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L3_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L3_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L3_V_P_3)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_1)         op1 value 0+
         DC    A(MP1_OP2_L3_V_P_4)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L3_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L3_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L3_V_P_3)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_2)         op1 value 0+
         DC    A(MP1_OP2_L3_V_P_4)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_3)         op1 value nz+
         DC    A(MP1_OP2_L3_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_3)         op1 value nz+
         DC    A(MP1_OP2_L3_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_4)         op1 value nz+
         DC    A(MP1_OP2_L3_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L7_V_P_4)         op1 value nz+
         DC    A(MP1_OP2_L3_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 11 * op2 len 5
*
         DC    A(MP1_OP1_L11_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L5_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L5_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L5_V_P_3)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L5_V_P_4)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L5_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L5_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L5_V_P_3)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L5_V_P_4)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_3)        op1 value nz+
         DC    A(MP1_OP2_L5_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_3)        op1 value nz+
         DC    A(MP1_OP2_L5_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_4)        op1 value nz+
         DC    A(MP1_OP2_L5_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L11_V_P_4)        op1 value nz+
         DC    A(MP1_OP2_L5_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 16 * op2 len 8
*
         DC    A(MP1_OP1_L16_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L8_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L8_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L8_V_P_3)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_1)        op1 value 0+
         DC    A(MP1_OP2_L8_V_P_4)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L8_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L8_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L8_V_P_3)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_2)        op1 value 0+
         DC    A(MP1_OP2_L8_V_P_4)         op2 value nz+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_3)        op1 value nz+
         DC    A(MP1_OP2_L8_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_3)        op1 value nz+
         DC    A(MP1_OP2_L8_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_4)        op1 value nz+
         DC    A(MP1_OP2_L8_V_P_1)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
         DC    A(MP1_OP1_L16_V_P_4)        op1 value nz+
         DC    A(MP1_OP2_L8_V_P_2)         op2 value 0+
         DC    A(MP1EVZP)                  expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
MP1PLPN  EQU   *-16,16                     Last parameter

***********************************************************************
*        Values for op1 and op2
***********************************************************************
*
MP1_OP1_L3_V_N_1 DS    0X                  op1 len 3 negative value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00000B'         Value
*
MP1_OP1_L3_V_N_2 DS    0X                  op1 len 3 negative value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00000D'         Value
*
MP1_OP1_L3_V_N_3 DS    0X                  op1 len 3 negative value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00999B'         Value
*
MP1_OP1_L3_V_N_4 DS    0X                  op1 len 3 negative value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00999D'         Value
*
MP1_OP1_L3_V_P_1 DS    0X                  op1 len 3 positive value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00000A'         Value
*
MP1_OP1_L3_V_P_2 DS    0X                  op1 len 3 positive value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00000C'         Value
*
MP1_OP1_L3_V_P_3 DS    0X                  op1 len 3 positive value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00999A'         Value
*
MP1_OP1_L3_V_P_4 DS    0X                  op1 len 3 positive value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00999C'         Value
*
*----------------------------------------------------------------------
*
MP1_OP1_L7_V_N_1 DS    0X                  op1 len 7 negative value
                 DC    AL1(7-1)            Length code
                 DC    XL7'0000000000000B' Value
*
MP1_OP1_L7_V_N_2 DS    0X                  op1 len 7 negative value
                 DC    AL1(7-1)            Length code
                 DC    XL7'0000000000000D' Value
*
MP1_OP1_L7_V_N_3 DS    0X                  op1 len 7 negative value
                 DC    AL1(7-1)            Length code
                 DC    XL7'0000009999999B' Value
*
MP1_OP1_L7_V_N_4 DS    0X                  op1 len 7 negative value
                 DC    AL1(7-1)            Length code
                 DC    XL7'0000009999999D' Value
*
MP1_OP1_L7_V_P_1 DS    0X                  op1 len 7 positive value
                 DC    AL1(7-1)            Length code
                 DC    XL7'0000000000000A' Value
*
MP1_OP1_L7_V_P_2 DS    0X                  op1 len 7 positive value
                 DC    AL1(7-1)            Length code
                 DC    XL7'0000000000000C' Value
*
MP1_OP1_L7_V_P_3 DS    0X                  op1 len 7 positive value
                 DC    AL1(7-1)            Length code
                 DC    XL7'0000009999999A' Value
*
MP1_OP1_L7_V_P_4 DS    0X                  op1 len 7 positive value
                 DC    AL1(7-1)            Length code
                 DC    XL7'0000009999999C' Value
*
*----------------------------------------------------------------------
*
MP1_OP1_L11_V_N_1 DS   0X                  op1 len 11 negative value
                 DC    AL1(11-1)           Length code
                 DC    XL11'000000000000000000000B'    Value
*
MP1_OP1_L11_V_N_2 DS   0X                  op1 len 11 negative value
                 DC    AL1(11-1)           Length code
                 DC    XL11'000000000000000000000D'    Value
*
MP1_OP1_L11_V_N_3 DS   0X                  op1 len 11 negative value
                 DC    AL1(11-1)           Length code
                 DC    XL11'000000000099999999999B'    Value
*
MP1_OP1_L11_V_N_4 DS   0X                  op1 len 11 negative value
                 DC    AL1(11-1)           Length code
                 DC    XL11'000000000099999999999D'    Value
*
MP1_OP1_L11_V_P_1 DS   0X                  op1 len 11 positive value
                 DC    AL1(11-1)           Length code
                 DC    XL11'000000000000000000000A'    Value
*
MP1_OP1_L11_V_P_2 DS   0X                  op1 len 11 positive value
                 DC    AL1(11-1)           Length code
                 DC    XL11'000000000000000000000C'    Value
*
MP1_OP1_L11_V_P_3 DS   0X                  op1 len 11 positive value
                 DC    AL1(11-1)           Length code
                 DC    XL11'000000000099999999999A'    Value
*
MP1_OP1_L11_V_P_4 DS   0X                  op1 len 11 positive value
                 DC    AL1(11-1)           Length code
                 DC    XL11'000000000099999999999C'    Value
*
*----------------------------------------------------------------------
*
MP1_OP1_L16_V_N_1 DS   0X                  op1 len 16 negative value
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000000000000000000B'  Value
*
MP1_OP1_L16_V_N_2 DS   0X                  op1 len 16 negative value
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000000000000000000D'  Value
*
MP1_OP1_L16_V_N_3 DS   0X                  op1 len 16 negative value
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000999999999999999B'  Value
*
MP1_OP1_L16_V_N_4 DS   0X                  op1 len 16 negative value
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000999999999999999D'  Value
*
MP1_OP1_L16_V_P_1 DS   0X                  op1 len 16 positive value
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000000000000000000A'  Value
*
MP1_OP1_L16_V_P_2 DS   0X                  op1 len 16 positive value
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000000000000000000C'  Value
*
MP1_OP1_L16_V_P_3 DS   0X                  op1 len 16 positive value
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000999999999999999A'  Value
*
MP1_OP1_L16_V_P_4 DS   0X                  op1 len 16 positive value
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000999999999999999C'  Value
*
***********************************************************************
*
MP1_OP2_L1_V_N_1 DS    0X                  op2 len 1 negative value
                 DC    AL1(1-1)            Length code
                 DC    XL1'0B'             Value
*
MP1_OP2_L1_V_N_2 DS    0X                  op2 len 1 negative value
                 DC    AL1(1-1)            Length code
                 DC    XL1'0D'             Value
*
MP1_OP2_L1_V_N_3 DS    0X                  op2 len 1 negative value
                 DC    AL1(1-1)            Length code
                 DC    XL1'9B'             Value
*
MP1_OP2_L1_V_N_4 DS    0X                  op2 len 1 negative value
                 DC    AL1(1-1)            Length code
                 DC    XL1'9D'             Value
*
MP1_OP2_L1_V_P_1 DS    0X                  op2 len 1 positive value
                 DC    AL1(1-1)            Length code
                 DC    XL1'0A'             Value
*
MP1_OP2_L1_V_P_2 DS    0X                  op2 len 1 positive value
                 DC    AL1(1-1)            Length code
                 DC    XL1'0C'             Value
*
MP1_OP2_L1_V_P_3 DS    0X                  op2 len 1 positive value
                 DC    AL1(1-1)            Length code
                 DC    XL1'9A'             Value
*
MP1_OP2_L1_V_P_4 DS    0X                  op2 len 1 positive value
                 DC    AL1(1-1)            Length code
                 DC    XL1'9C'             Value
*
*----------------------------------------------------------------------
*
MP1_OP2_L3_V_N_1 DS    0X                  op2 len 3 negative value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00000B'         Value
*
MP1_OP2_L3_V_N_2 DS    0X                  op2 len 3 negative value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00000D'         Value
*
MP1_OP2_L3_V_N_3 DS    0X                  op2 len 3 negative value
                 DC    AL1(3-1)            Length code
                 DC    XL3'99999B'         Value
*
MP1_OP2_L3_V_N_4 DS    0X                  op2 len 3 negative value
                 DC    AL1(3-1)            Length code
                 DC    XL3'99999D'         Value
*
MP1_OP2_L3_V_P_1 DS    0X                  op2 len 3 positive value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00000A'         Value
*
MP1_OP2_L3_V_P_2 DS    0X                  op2 len 3 positive value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00000C'         Value
*
MP1_OP2_L3_V_P_3 DS    0X                  op2 len 3 positive value
                 DC    AL1(3-1)            Length code
                 DC    XL3'99999A'         Value
*
MP1_OP2_L3_V_P_4 DS    0X                  op2 len 3 positive value
                 DC    AL1(3-1)            Length code
                 DC    XL3'99999C'         Value
*
*----------------------------------------------------------------------
*
MP1_OP2_L5_V_N_1 DS    0X                  op2 len 7 negative value
                 DC    AL1(5-1)            Length code
                 DC    XL5'000000000B'     Value
*
MP1_OP2_L5_V_N_2 DS    0X                  op2 len 7 negative value
                 DC    AL1(5-1)            Length code
                 DC    XL5'000000000D'     Value
*
MP1_OP2_L5_V_N_3 DS    0X                  op2 len 7 negative value
                 DC    AL1(5-1)            Length code
                 DC    XL5'999999999B'     Value
*
MP1_OP2_L5_V_N_4 DS    0X                  op2 len 7 negative value
                 DC    AL1(5-1)            Length code
                 DC    XL5'999999999D'     Value
*
MP1_OP2_L5_V_P_1 DS    0X                  op2 len 7 positive value
                 DC    AL1(5-1)            Length code
                 DC    XL5'000000000A'     Value
*
MP1_OP2_L5_V_P_2 DS    0X                  op2 len 7 positive value
                 DC    AL1(5-1)            Length code
                 DC    XL5'000000000C'     Value
*
MP1_OP2_L5_V_P_3 DS    0X                  op2 len 7 positive value
                 DC    AL1(5-1)            Length code
                 DC    XL5'999999999A'     Value
*
MP1_OP2_L5_V_P_4 DS    0X                  op2 len 7 positive value
                 DC    AL1(5-1)            Length code
                 DC    XL5'999999999C'     Value
*
*----------------------------------------------------------------------
*
MP1_OP2_L8_V_N_1 DS    0X                  op2 len 11 negative value
                 DC    AL1(8-1)            Length code
                 DC    XL8'000000000000000B'   Value
*
MP1_OP2_L8_V_N_2 DS    0X                  op2 len 11 negative value
                 DC    AL1(8-1)            Length code
                 DC    XL8'000000000000000D'   Value
*
MP1_OP2_L8_V_N_3 DS    0X                  op2 len 11 negative value
                 DC    AL1(8-1)            Length code
                 DC    XL8'999999999999999B'   Value
*
MP1_OP2_L8_V_N_4 DS    0X                  op2 len 11 negative value
                 DC    AL1(8-1)            Length code
                 DC    XL8'999999999999999D'   Value
*
MP1_OP2_L8_V_P_1 DS    0X                  op2 len 11 positive value
                 DC    AL1(8-1)            Length code
                 DC    XL8'000000000000000A'   Value
*
MP1_OP2_L8_V_P_2 DS    0X                  op2 len 11 positive value
                 DC    AL1(8-1)            Length code
                 DC    XL8'000000000000000C'   Value
*
MP1_OP2_L8_V_P_3 DS    0X                  op2 len 11 positive value
                 DC    AL1(8-1)            Length code
                 DC    XL8'999999999999999A'   Value
*
MP1_OP2_L8_V_P_4 DS    0X                  op2 len 11 positive value
                 DC    AL1(8-1)            Length code
                 DC    XL8'999999999999999C'   Value
*
***********************************************************************
*
***********************************************************************
*        Expected values
***********************************************************************
*
*        x- * 0+  or  x+ * 0-
*                  --
MP1EVZN  DC    XL16'0D'            0-
*
*        x- * 0-  or  x+ * 0+
*                  --
MP1EVZP  DC    XL16'0C'            0+
*
         DROP  R11,R12             End addressability
*
***********************************************************************
*
* Routine: T02
*
*        MP   op1,op2  No error; product is non-zero.
*
***********************************************************************
*
*        Operand lengths used are shown in the following table:
*
*            op1 length    op2 length
*            ----------    ----------
*                 3             1
*                 7             3
*                11             7
*                16            11
*
*        Two sign nibbles are used for negative: B, D.
*        Two sign nibbles are used for positive: A, C.
*
*        Tests are summarized below. 
*
***********************************************************************
*
*        Result negative
*
*        op1 < 0
*        op2 > 0
*
*        op1 > 0
*        op2 < 0
*
*        All tests should complete with condition code unchanged
*        and have sign nibble D.
*
*        There are 4 * 4 = 16 tests for each of the three test cases,
*        so there are 3 * 4 * 4 = 48 test cases when the result is
*        negative.
*     
***********************************************************************
*
*        Result positive
*
*        op1 < 0
*        op2 < 0
*
*        op1 > 0
*        op2 > 0
*
*        All tests should complete with condition code unchanged
*        and have sign nibble C.
*
*        There are 4 * 4 = 16 tests for each of the three test cases,
*        so there are 3 * 4 * 4 = 48 test cases when the result is
*        positive.
*
***********************************************************************
*
*        Total number of tests = 48 + 48 + 32 = 128.
*
*        Total number of failures, total number of successes,
*        stored in common storage fields MP02#F, MP02#S,
*        respectively.
*
***********************************************************************
*
         Using Data,R11            R11 --> data always
T02      DS    0H
         STM   R14,R12,12(R13)     Save caller's registers
         L     R13,8(,R13)         Next save area
         LR    R12,R15             R12 = base register
         USING T02,R12             Establish addressability
*
         LM    R1,R3,MP2PLP        R1 --> 1st parameter list
*                                  R2  =  len one parameter list
*                                  R3 --> last parameter list
*
         SR    R9,R9               R9 = number of tests that fail
         LR    R10,R9              R10 = number of tests that succeed
*
         MVI   WT#,C'2'            Test number for print
*
         MVI   WExpABCC,X'FF'      Abends are not expected
*
T02100   DS    0H
         BAS   R14,T02Mul          Perform one multiplication
         LTR   R15,R15             Test successful?
         BZ    T02200              Yes; count success
         AHI   R9,1                No; count failure
         B     T02300              Continue
T02200   DS    0H
         AHI   R10,1               Count success
T02300   DS    0H
         LARL  R15,PrtRes          Print routine
         BASR  R14,R15             Print results
         BXLE  R1,R2,T02100        Process all parameter lists
*
         STM   R9,R10,MP02ST       Save # failures, # successes
*
         L     R13,4(,R13)         Caller's save area
         LM    R14,R12,12(R13)     Restore caller's registers
         BR    R14                 Return to caller
*
***********************************************************************
*
* Routine: T02Mul
*
*        Perform one MP test
*
*        Input:
*
*            R1 --> parameter list
*                   +0 --> value for op1; 1st byte len code
*                   +4 --> value for op2; 1st byte len code
*                   +8 --> expected product; 16 bytes; no len code
*                   +C  =  expected CC
*
*        Output:
*
*            WErr    report error indicator; ' ' no error; '*' error
*
*            WCC     condition code after instruction executed
*                    X'FF' in leftmost byte if instruction not executed
*
*            WResult set to result; left-justified in 16-byte field
*                    X'FF' in leftmost byte if instruction not executed
*
*        Return code:  0 test succeeded
*                      4 test failed
*                     16 invalid op1,op2 length code pair
*
***********************************************************************
*
T02Mul   DS    0H
         STM   R14,R12,12(R13)     Save caller's registers
         L     R13,8(,R13)         Next save area
*
         LM    R2,R4,0(R1)         R2 --> op1 value
*                                  R3 --> op2 value
*                                  R4 --> expected product; 16 bytes
         L     R0,12(,R1)          R0  =  expected CC
*
         MVI   WErr,C' '           No failure
         MVI   WCC,X'FF'           No CC; instruction not executed
         MVI   WResult,X'FF'       No result; instruction not executed
*
         SR    R5,R5               Prepare to get op1 len code
         SR    R6,R6               Prepare to get op2 len code
         IC    R5,0(,R2)           op1 len code; 0 - 15
         SLL   R5,4                Move left one nibble
         IC    R6,0(,R3)           op2 len code; 0 - 15
         OR    R5,R6               R5 = op1LC || op2LC
         IC    R5,T02TT(R5)        Get branch table index
         SLL   R5,2                Convert to offset
         TM    *,X'91'             Set CC 3
         B     T02MulBT(R5)        Branch to appropriate code
T02MulBT DS    0H
         B     T02MulER            Skip; invalid (op1 len, op2 len)
         B     T02Mul_3_1          op1 len 3, op2 len 1
         B     T02Mul_7_3          op1 len 7, op2 len 3
         B     T02Mul_11_5         op1 len 10, op2 len 5
         B     T02Mul_16_8         op1 len 16, op2 len 8
*
T02Mul_3_1     DS    0H
         MVC   W1L3,1(R2)          Copy op1 value to work
         MVC   W2L1,1(R3)          Copy op2 value to work
         LA    R5,W1L3             R5 --> result
         LA    R6,L'W1L3-1         R6  =  len code of result
         MP    W1L3,W2L1           Do the multiplication
         B     T02MulCR            Check the result
T02Mul_7_3     DS    0H
         MVC   W1L7,1(R2)          Copy op1 value to work
         MVC   W2L3,1(R3)          Copy op2 value to work
         LA    R5,W1L7             R5 --> result
         LA    R6,L'W1L7-1         R6  =  len code of result
         MP    W1L7,W2L3           Do the multiplication
         B     T02MulCR            Check the result
T02Mul_11_5    DS    0H
         MVC   W1L11,1(R2)         Copy op1 value to work
         MVC   W2L5,1(R3)          Copy op2 value to work
         LA    R5,W1L11            R5 --> result
         LA    R6,L'W1L11-1        R6  =  len code of result
         MP    W1L11,W2L5          Do the multiplication
         B     T02MulCR            Check the result
T02Mul_16_8    DS    0H
         MVC   W1L16,1(R2)         Copy op1 value to work
         MVC   W2L8,1(R3)          Copy op2 value to work
         LA    R5,W1L16            R5 --> result
         LA    R6,L'W1L16-1        R6  =  len code of result
         MP    W1L16,W2L8          Do the multipllication
         B     T02MulCR            Check the result
*
T02MulER DS    0H
         LA    R15,16              Invalid op1,op2 len code pair
         B     T02MulDone          Done
T02MulCR DS    0H
         IPM   R15                 Get CC, Pgm Mask
         SRL   R15,28              Isolate CC
         ST    R15,WCC             Save in print work area
         EX    R6,T02MVC           Copy result to print work area
         BAS   R14,T02CkRs         Check result; sets R15
T02MulDone     DS    0H
         LTR   R15,R15             Errpr or check failed?
         BZ    T02MulExit          No; just exit
         MVI   WErr,C'*'           Yes; set error indicator
T02MulExit     DS    0H
         L     R13,4(,R13)         Caller's save area
         L     R14,12(,R13)        Restore caller's registers
         LM    R0,R12,20(R13)      ... except for R15
         BR    R14                 Return to caller
*
T02MVC   MVC   WResult(*-*),0(R5)  Copy result to work area
*
***********************************************************************
*
* Routine: T02CkRs
*
*        Check result
*
*        Input:
*
*          R0  =  expected CC
*          R15 =  actual CC
*          R5 --> op1
*          R6  =  len code of op1
*          R4 --> 16 byte expected result
*
*        Return code: 0 Test succeeded
*                     4 Test failed
*
***********************************************************************
*
T02CkRs  DS    0H
         CR    R15,R0              Actual CC = expected CC?
         BNE   T02F                Failure if not equal
         LA    R15,15(,R4)         Last byte of expected result
         SR    R15,R6              R15 --> op1 expected result
         EX    R6,T02CLC           op1 : expected
         BE    T02S                Success if equal
T02F     DS    0H
         LA    R15,4               Test failed
         B     T02D                Done
T02S     DS    0H
         SR    R15,R15             Test succeeded
*NSI     B     T02D                Done
T02D     DS    0H
         BR    R14                 Return
*
T02CLC   CLC   0(*-*,R5),0(R15)    op1 : expected result
*
***********************************************************************
*        Convert byte X'op1LC || op2LC' to branch table index
***********************************************************************
T02TT    DC    256AL1(0)           Translate table
         ORG   T02TT+X'20'         op1 len code 2, op2 len code 0
         DC    AL1(1)
         ORG   T02TT+X'62'         op1 len code 6, op2 len code 2
         DC    AL1(2)
         ORG   T02TT+X'A4'         op1 len code 10, op2 len code 4
         DC    AL1(3)
         ORG   T02TT+X'F7'         op1 len code 15, op2 len code 7
         DC    AL1(4)
         ORG   ,
*
         LTORG
*
***********************************************************************
*        Parameter lists for all tests
***********************************************************************
*
MP2PLP   DC    A(MP2PLP1,16,MP2PLPN)       1st plist, len 1, last plist
*
MP2PLP1  DS    0A                          first parameter list
***********************************************************************
*        negative * negative = positive
***********************************************************************
*
*        op1 len 3 * op2 len 1
*
         DC    A(MP2_OP1_L3_V_N_3)         op1 value nz-
         DC    A(MP2_OP2_L1_V_N_3)         op2 value nz-
         DC    A(MP2EV002)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L3_V_N_3)         op1 value nz-
         DC    A(MP2_OP2_L1_V_N_4)         op2 value nz-
         DC    A(MP2EV002)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L3_V_N_4)         op1 value nz-
         DC    A(MP2_OP2_L1_V_N_3)         op2 value nz-
         DC    A(MP2EV002)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L3_V_N_4)         op1 value nz-
         DC    A(MP2_OP2_L1_V_N_4)         op2 value nz-
         DC    A(MP2EV002)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 7 * op2 len 3
*
         DC    A(MP2_OP1_L7_V_N_3)         op1 value nz-
         DC    A(MP2_OP2_L3_V_N_3)         op2 value nz-
         DC    A(MP2EV004)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L7_V_N_3)         op1 value nz-
         DC    A(MP2_OP2_L3_V_N_4)         op2 value nz-
         DC    A(MP2EV004)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L7_V_N_4)         op1 value nz-
         DC    A(MP2_OP2_L3_V_N_3)         op2 value nz-
         DC    A(MP2EV004)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L7_V_N_4)         op1 value nz-
         DC    A(MP2_OP2_L3_V_N_4)         op2 value nz-
         DC    A(MP2EV004)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 11 * op2 len 5
*
         DC    A(MP2_OP1_L11_V_N_3)        op1 value nz-
         DC    A(MP2_OP2_L5_V_N_3)         op2 value nz-
         DC    A(MP2EV006)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L11_V_N_3)        op1 value nz-
         DC    A(MP2_OP2_L5_V_N_4)         op2 value nz-
         DC    A(MP2EV006)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L11_V_N_4)        op1 value nz-
         DC    A(MP2_OP2_L5_V_N_3)         op2 value nz-
         DC    A(MP2EV006)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L11_V_N_4)        op1 value nz-
         DC    A(MP2_OP2_L5_V_N_4)         op2 value nz-
         DC    A(MP2EV006)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 16 * op2 len 8
*
         DC    A(MP2_OP1_L16_V_N_3)        op1 value nz-
         DC    A(MP2_OP2_L8_V_N_3)        op2 value nz-
         DC    A(MP2EV008)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L16_V_N_3)        op1 value nz-
         DC    A(MP2_OP2_L8_V_N_4)        op2 value nz-
         DC    A(MP2EV008)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L16_V_N_4)        op1 value nz-
         DC    A(MP2_OP2_L8_V_N_3)        op2 value nz-
         DC    A(MP2EV008)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L16_V_N_4)        op1 value nz-
         DC    A(MP2_OP2_L8_V_N_4)        op2 value nz-
         DC    A(MP2EV008)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*        negative * postive = negative
***********************************************************************
*
*        op1 len 3 * op2 len 1
*
         DC    A(MP2_OP1_L3_V_N_3)         op1 value nz-
         DC    A(MP2_OP2_L1_V_P_3)         op2 value nz+
         DC    A(MP2EV001)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L3_V_N_3)         op1 value nz-
         DC    A(MP2_OP2_L1_V_P_4)         op2 value nz+
         DC    A(MP2EV001)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L3_V_N_4)         op1 value nz-
         DC    A(MP2_OP2_L1_V_P_3)         op2 value nz+
         DC    A(MP2EV001)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L3_V_N_4)         op1 value nz-
         DC    A(MP2_OP2_L1_V_P_4)         op2 value nz+
         DC    A(MP2EV001)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 7 * op2 len 3
*
         DC    A(MP2_OP1_L7_V_N_3)         op1 value nz-
         DC    A(MP2_OP2_L3_V_P_3)         op2 value nz+
         DC    A(MP2EV003)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L7_V_N_3)         op1 value nz-
         DC    A(MP2_OP2_L3_V_P_4)         op2 value nz+
         DC    A(MP2EV003)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L7_V_N_4)         op1 value nz-
         DC    A(MP2_OP2_L3_V_P_3)         op2 value nz+
         DC    A(MP2EV003)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L7_V_N_4)         op1 value nz-
         DC    A(MP2_OP2_L3_V_P_4)         op2 value nz+
         DC    A(MP2EV003)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 11 * op2 len 5
*
         DC    A(MP2_OP1_L11_V_N_3)        op1 value nz-
         DC    A(MP2_OP2_L5_V_P_3)         op2 value nz+
         DC    A(MP2EV005)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L11_V_N_3)        op1 value nz-
         DC    A(MP2_OP2_L5_V_P_4)         op2 value nz+
         DC    A(MP2EV005)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L11_V_N_4)        op1 value nz-
         DC    A(MP2_OP2_L5_V_P_3)         op2 value nz+
         DC    A(MP2EV005)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L11_V_N_4)        op1 value nz-
         DC    A(MP2_OP2_L5_V_P_4)         op2 value nz+
         DC    A(MP2EV005)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 16 * op2 len 8
*
         DC    A(MP2_OP1_L16_V_N_3)        op1 value nz-
         DC    A(MP2_OP2_L8_V_P_3)        op2 value nz+
         DC    A(MP2EV007)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L16_V_N_3)        op1 value nz-
         DC    A(MP2_OP2_L8_V_P_4)        op2 value nz+
         DC    A(MP2EV007)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L16_V_N_4)        op1 value nz-
         DC    A(MP2_OP2_L8_V_P_3)        op2 value nz+
         DC    A(MP2EV007)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L16_V_N_4)        op1 value nz-
         DC    A(MP2_OP2_L8_V_P_4)        op2 value nz+
         DC    A(MP2EV007)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*        positive * negative = negative
***********************************************************************
*
*        op1 len 3 * op2 len 1
*
         DC    A(MP2_OP1_L3_V_P_3)         op1 value nz+
         DC    A(MP2_OP2_L1_V_N_3)         op2 value nz-
         DC    A(MP2EV001)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L3_V_P_3)         op1 value nz+
         DC    A(MP2_OP2_L1_V_N_4)         op2 value nz-
         DC    A(MP2EV001)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L3_V_P_4)         op1 value nz+
         DC    A(MP2_OP2_L1_V_N_3)         op2 value nz-
         DC    A(MP2EV001)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L3_V_P_4)         op1 value nz+
         DC    A(MP2_OP2_L1_V_N_4)         op2 value nz-
         DC    A(MP2EV001)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 7 * op2 len 3
*
         DC    A(MP2_OP1_L7_V_P_3)         op1 value nz+
         DC    A(MP2_OP2_L3_V_N_3)         op2 value nz-
         DC    A(MP2EV003)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L7_V_P_3)         op1 value nz+
         DC    A(MP2_OP2_L3_V_N_4)         op2 value nz-
         DC    A(MP2EV003)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L7_V_P_4)         op1 value nz+
         DC    A(MP2_OP2_L3_V_N_3)         op2 value nz-
         DC    A(MP2EV003)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L7_V_P_4)         op1 value nz+
         DC    A(MP2_OP2_L3_V_N_4)         op2 value nz-
         DC    A(MP2EV003)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 11 * op2 len 5
*
         DC    A(MP2_OP1_L11_V_P_3)        op1 value nz+
         DC    A(MP2_OP2_L5_V_N_3)         op2 value nz-
         DC    A(MP2EV005)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L11_V_P_3)        op1 value nz+
         DC    A(MP2_OP2_L5_V_N_4)         op2 value nz-
         DC    A(MP2EV005)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L11_V_P_4)        op1 value nz+
         DC    A(MP2_OP2_L5_V_N_3)         op2 value nz-
         DC    A(MP2EV005)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L11_V_P_4)        op1 value nz+
         DC    A(MP2_OP2_L5_V_N_4)         op2 value nz-
         DC    A(MP2EV005)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 16 * op2 len 8
*
         DC    A(MP2_OP1_L16_V_P_3)        op1 value nz+
         DC    A(MP2_OP2_L8_V_N_3)        op2 value nz-
         DC    A(MP2EV007)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L16_V_P_3)        op1 value nz+
         DC    A(MP2_OP2_L8_V_N_4)        op2 value nz-
         DC    A(MP2EV007)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L16_V_P_4)        op1 value nz+
         DC    A(MP2_OP2_L8_V_N_3)        op2 value nz-
         DC    A(MP2EV007)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L16_V_P_4)        op1 value nz+
         DC    A(MP2_OP2_L8_V_N_4)        op2 value nz-
         DC    A(MP2EV007)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*        positive * postive = positive
***********************************************************************
*
*        op1 len 3 * op2 len 1
*
         DC    A(MP2_OP1_L3_V_P_3)         op1 value nz+
         DC    A(MP2_OP2_L1_V_P_3)         op2 value nz+
         DC    A(MP2EV002)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L3_V_P_3)         op1 value nz+
         DC    A(MP2_OP2_L1_V_P_4)         op2 value nz+
         DC    A(MP2EV002)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L3_V_P_4)         op1 value nz+
         DC    A(MP2_OP2_L1_V_P_3)         op2 value nz+
         DC    A(MP2EV002)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L3_V_P_4)         op1 value nz+
         DC    A(MP2_OP2_L1_V_P_4)         op2 value nz+
         DC    A(MP2EV002)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 7 * op2 len 3
*
         DC    A(MP2_OP1_L7_V_P_3)         op1 value nz+
         DC    A(MP2_OP2_L3_V_P_3)         op2 value nz+
         DC    A(MP2EV004)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L7_V_P_3)         op1 value nz+
         DC    A(MP2_OP2_L3_V_P_4)         op2 value nz+
         DC    A(MP2EV004)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L7_V_P_4)         op1 value nz+
         DC    A(MP2_OP2_L3_V_P_3)         op2 value nz+
         DC    A(MP2EV004)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L7_V_P_4)         op1 value nz+
         DC    A(MP2_OP2_L3_V_P_4)         op2 value nz+
         DC    A(MP2EV004)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 11 * op2 len 5
*
         DC    A(MP2_OP1_L11_V_P_3)        op1 value nz+
         DC    A(MP2_OP2_L5_V_P_3)         op2 value nz+
         DC    A(MP2EV006)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L11_V_P_3)        op1 value nz+
         DC    A(MP2_OP2_L5_V_P_4)         op2 value nz+
         DC    A(MP2EV006)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L11_V_P_4)        op1 value nz+
         DC    A(MP2_OP2_L5_V_P_3)         op2 value nz+
         DC    A(MP2EV006)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L11_V_P_4)        op1 value nz+
         DC    A(MP2_OP2_L5_V_P_4)         op2 value nz+
         DC    A(MP2EV006)                 expected product
         DC    A(3)                        expected CC
*
***********************************************************************
*
*        op1 len 16 * op2 len 8
*
         DC    A(MP2_OP1_L16_V_P_3)        op1 value nz+
         DC    A(MP2_OP2_L8_V_P_3)        op2 value nz+
         DC    A(MP2EV008)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L16_V_P_3)        op1 value nz+
         DC    A(MP2_OP2_L8_V_P_4)        op2 value nz+
         DC    A(MP2EV008)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L16_V_P_4)        op1 value nz+
         DC    A(MP2_OP2_L8_V_P_3)        op2 value nz+
         DC    A(MP2EV008)                 expected product
         DC    A(3)                        expected CC
*
         DC    A(MP2_OP1_L16_V_P_4)        op1 value nz+
         DC    A(MP2_OP2_L8_V_P_4)        op2 value nz+
         DC    A(MP2EV008)                 expected product
         DC    A(3)                        expected CC
*
MP2PLPN  EQU   *-16,16                     Last parameter

***********************************************************************
*        Values for op1 and op2
***********************************************************************
*
***********************************************************************
*        Values for op1 and op2 (same as T01 non-zero values)
***********************************************************************
*
MP2_OP1_L3_V_N_3 DS    0X                  op1 len 3 negative value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00999B'         Value
*
MP2_OP1_L3_V_N_4 DS    0X                  op1 len 3 negative value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00999D'         Value
*
MP2_OP1_L3_V_P_3 DS    0X                  op1 len 3 positive value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00999A'         Value
*
MP2_OP1_L3_V_P_4 DS    0X                  op1 len 3 positive value
                 DC    AL1(3-1)            Length code
                 DC    XL3'00999C'         Value
*
*----------------------------------------------------------------------
*
MP2_OP1_L7_V_N_3 DS    0X                  op1 len 7 negative value
                 DC    AL1(7-1)            Length code
                 DC    XL7'0000009999999B' Value
*
MP2_OP1_L7_V_N_4 DS    0X                  op1 len 7 negative value
                 DC    AL1(7-1)            Length code
                 DC    XL7'0000009999999D' Value
*
MP2_OP1_L7_V_P_3 DS    0X                  op1 len 7 positive value
                 DC    AL1(7-1)            Length code
                 DC    XL7'0000009999999A' Value
*
MP2_OP1_L7_V_P_4 DS    0X                  op1 len 7 positive value
                 DC    AL1(7-1)            Length code
                 DC    XL7'0000009999999C' Value
*
*----------------------------------------------------------------------
*
MP2_OP1_L11_V_N_3 DS   0X                  op1 len 11 negative value
                 DC    AL1(11-1)           Length code
                 DC    XL11'000000000099999999999B'    Value
*
MP2_OP1_L11_V_N_4 DS   0X                  op1 len 11 negative value
                 DC    AL1(11-1)           Length code
                 DC    XL11'000000000099999999999D'    Value
*
MP2_OP1_L11_V_P_3 DS   0X                  op1 len 11 positive value
                 DC    AL1(11-1)           Length code
                 DC    XL11'000000000099999999999A'    Value
*
MP2_OP1_L11_V_P_4 DS   0X                  op1 len 11 positive value
                 DC    AL1(11-1)           Length code
                 DC    XL11'000000000099999999999C'    Value
*
*----------------------------------------------------------------------
*
MP2_OP1_L16_V_N_3 DS   0X                  op1 len 16 negative value
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000999999999999999B'  Value
*
MP2_OP1_L16_V_N_4 DS   0X                  op1 len 16 negative value
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000999999999999999D'  Value
*
MP2_OP1_L16_V_P_3 DS   0X                  op1 len 16 positive value
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000999999999999999A'  Value
*
MP2_OP1_L16_V_P_4 DS   0X                  op1 len 16 positive value
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000999999999999999C'  Value
*
***********************************************************************
*
MP2_OP2_L1_V_N_3 DS    0X                  op2 len 1 negative value
                 DC    AL1(1-1)            Length code
                 DC    XL1'9B'             Value
*
MP2_OP2_L1_V_N_4 DS    0X                  op2 len 1 negative value
                 DC    AL1(1-1)            Length code
                 DC    XL1'9D'             Value
*
MP2_OP2_L1_V_P_3 DS    0X                  op2 len 1 positive value
                 DC    AL1(1-1)            Length code
                 DC    XL1'9A'             Value
*
MP2_OP2_L1_V_P_4 DS    0X                  op2 len 1 positive value
                 DC    AL1(1-1)            Length code
                 DC    XL1'9C'             Value
*
*----------------------------------------------------------------------
*
MP2_OP2_L3_V_N_3 DS    0X                  op2 len 3 negative value
                 DC    AL1(3-1)            Length code
                 DC    XL3'99999B'         Value
*
MP2_OP2_L3_V_N_4 DS    0X                  op2 len 3 negative value
                 DC    AL1(3-1)            Length code
                 DC    XL3'99999D'         Value
*
MP2_OP2_L3_V_P_3 DS    0X                  op2 len 3 positive value
                 DC    AL1(3-1)            Length code
                 DC    XL3'99999A'         Value
*
MP2_OP2_L3_V_P_4 DS    0X                  op2 len 3 positive value
                 DC    AL1(3-1)            Length code
                 DC    XL3'99999C'         Value
*
*----------------------------------------------------------------------
*
MP2_OP2_L5_V_N_3 DS    0X                  op2 len 7 negative value
                 DC    AL1(5-1)            Length code
                 DC    XL5'999999999B'     Value
*
MP2_OP2_L5_V_N_4 DS    0X                  op2 len 7 negative value
                 DC    AL1(5-1)            Length code
                 DC    XL5'999999999D'     Value
*
MP2_OP2_L5_V_P_3 DS    0X                  op2 len 7 positive value
                 DC    AL1(5-1)            Length code
                 DC    XL5'999999999A'     Value
*
MP2_OP2_L5_V_P_4 DS    0X                  op2 len 7 positive value
                 DC    AL1(5-1)            Length code
                 DC    XL5'999999999C'     Value
*
*----------------------------------------------------------------------
*
MP2_OP2_L8_V_N_3 DS    0X                  op2 len 8 negative value
                 DC    AL1(8-1)            Length code
                 DC    XL8'999999999999999B'   Value
*
MP2_OP2_L8_V_N_4 DS    0X                  op2 len 8 negative value
                 DC    AL1(8-1)            Length code
                 DC    XL8'999999999999999D'   Value
*
MP2_OP2_L8_V_P_3 DS    0X                  op2 len 8 positive value
                 DC    AL1(8-1)            Length code
                 DC    XL8'999999999999999A'   Value
*
MP2_OP2_L8_V_P_4 DS    0X                  op2 len 8 positive value
                 DC    AL1(8-1)            Length code
                 DC    XL8'999999999999999C'   Value
*
***********************************************************************
*        Expected values
***********************************************************************
*
*               -00999     or     00999
*             *      9         *     -9
*                   --           ------
MP2EV001 DC    XL16'8991D'
*
*               00999     or    -00999
*            *     -9         *      9 
*                  --           ------
MP2EV002 DC    XL16'8991C'
*
*       -0000009999999     or     0000009999999
*      *         99999         *         -99999
*       --------------           --------------
MP2EV003 DC    XL16'999989900001D'
*
*       -0000009999999     or     0000009999999
*      *        -99999         *          99999
*       --------------           --------------
MP2EV004 DC    XL16'999989900001C'
*
*       -0000000000999999999999     or     0000000000999999999999
*      *              999999999         *              -999999999
*       -----------------------            ----------------------
MP2EV005 DC    XL16'99999999899000000001D'
*
*       -0000000000999999999999     or     0000000000999999999999
*      *             -999999999         *               999999999
*       -----------------------            ----------------------
MP2EV006 DC    XL16'99999999899000000001C'
*
*  -0000000000000000999999999999999 or 0000000000000000999999999999999
* *                 999999999999999  *                -999999999999999
*  --------------------------------    -------------------------------
MP2EV007 DC    XL16'999999999999998000000000000001D'
*
*  -0000000000000000999999999999999 or 0000000000000000999999999999999
* *                -999999999999999  *                 999999999999999
*  --------------------------------    -------------------------------
MP2EV008 DC    XL16'999999999999998000000000000001C'
*
         DROP  R11,R12             End addressability
*
***********************************************************************
*
* Routine: T03
*
*        MP   op1,op2  op1 does not have enough leading zeros.
*
*        All tests should result in a data exception (S0C7).
*
*        A successful test is one that results in a data exception.
*
*        Four tests, each with two cases. See following table.
*
*            op1 len    op2 len    op1 op2 values good or bad
*            -------    -------    --------------------------
*               3          1       op1 has some leading zeros
*                                  op1 has no leading zeros
*               7          3       op1 has some leading zeros
*                                  op1 has no leading zeros
*              11          5       op1 has some leading zeros
*                                  op1 has no leading zeros
*              16          8       op1 has some leading zeros
*                                  op1 has no leading zeros
*
*        Total number of test cases = 4 * 2 = 8.
*
*        Total number of failures, total number of successes,
*        stored in common storage fields MP03#F, MP03#S,
*        respectively.
*
***********************************************************************
*
         Using Data,R11            R11 --> data always
T03      DS    0H
         STM   R14,R12,12(R13)     Save caller's registers
         L     R13,8(,R13)         Next save area
         LR    R12,R15             R12 = base register
         USING T03,R12             Establish addressability
*
         LM    R1,R3,MP3PLP        R1 --> 1st parameter list
*                                  R2  =  len one parameter list
*                                  R3 --> last parameter list
*
         SR    R9,R9               R9 = number of tests that fail
         LR    R10,R9              R10 = number of tests that succeed
*
         MVI   WT#,C'3'            Test number for print
*
         MVI   WExpABCC,X'00'      Abends are expected
*
T03100   DS    0H
         BAS   R14,T03Mul          Perform one multiplication
         LTR   R15,R15             Test successful?
         BZ    T03200              Yes; count success
         AHI   R9,1                No; count failure
         B     T03300              Continue
T03200   DS    0H
         AHI   R10,1               Count success
T03300   DS    0H
         LARL  R15,PrtRes          Print routine
         BASR  R14,R15             Print results
         BXLE  R1,R2,T03100        Process all parameter lists
*
         STM   R9,R10,MP03ST       Save # failures, # successes
*
         L     R13,4(,R13)         Caller's save area
         LM    R14,R12,12(R13)     Restore caller's registers
         BR    R14                 Return to caller
*
***********************************************************************
*
* Routine: T03Mul
*
*        Perform one MP test
*
*        The MP is expected to result in a data exception (S0C7).
*        An ESTAE is created to trap the abend and retry to indicate
*        that the test is successful.
*
*        Input:
*
*            R1 --> parameter list
*                   +0 --> value for op1; 1st byte len code
*                   +4 --> value for op2; 1st byte len code
*                   +8 --> expected product; 16 bytes; no len code
*                   +C  =  expected CC
*
*        Note: the 3rd and 4th parameters are not used since the
*              MP is expected to result in a data exception.
*
*        Output:
*
*            WErr    report error indicator; ' ' no error; '*' error
*
*            WCC     condition code after instruction executed
*                    X'FF' in leftmost byte if instruction not executed
*
*            WResult set to result; left-justified in 16-byte field
*                    X'FF' in leftmost byte if instruction not executed
*
*            WActABCC set to abend completion code if abend occurs;
*                     zeros if no abend
*
*            WExpABCC set to expected abend completion code
*
*        Return code:  0 test succeeded
*                      4 test failed
*                     16 invalid op1,op2 length code pair
*
***********************************************************************
*
T03Mul   DS    0H
         STM   R14,R12,12(R13)     Save caller's registers
*
         LA    R3,ESPARM           Parm list for ESTAE exit
         MVI   ESF1,ESF10C7        Initialize ESTAE flag
         LA    R0,T03Mul0C7        Retry address
         ST    R0,ESRET@           Save in ESTAE parm list
         LARL  R4,ESTAEEX          ESTAE exit
         ESTAE (R4),PARAM=(R3)     Set ESTAE
*
         L     R1,24(,R13)         Restore R1
*
         L     R13,8(,R13)         Next save area
*
         LM    R2,R3,0(R1)         R2 --> op1 value
*                                  R3 --> op2 value
*
*        Note: third and fourth parameters not used!
*
         MVI   WErr,C' '           No failure
         MVI   WCC,X'FF'           No CC; instruction not executed
         MVI   WResult,X'FF'       No result; instruction not executed
*
         XC    WActABCC,WActABCC   No completion code yet
         MVC   WExpABCC,ABCC0C7    Copy expected ABCC to print area
*
         SR    R5,R5               Prepare to get op1 len code
         SR    R6,R6               Prepare to get op2 len code
         IC    R5,0(,R2)           op1 len code; 0 - 15
         SLL   R5,4                Move left one nibble
         IC    R6,0(,R3)           op2 len code; 0 - 15
         OR    R5,R6               R5 = op1LC || op2LC
         IC    R5,T03TT(R5)        Get branch table index
         SLL   R5,2                Convert to offset
         TM    *,X'91'             Set CC 3
         B     T03MulBT(R5)        Branch to appropriate code
T03MulBT DS    0H
         B     T03MulER            Skip; invalid (op1 len, op2 len)
         B     T03Mul_3_1          op1 len 3, op2 len 1
         B     T03Mul_7_3          op1 len 7, op2 len 5
         B     T03Mul_11_5         op1 len 10, op2 len 5
         B     T03Mul_16_8         op1 len 16, op2 len 8
*
T03Mul_3_1     DS    0H
         MVC   W1L3,1(R2)          Copy op1 value to work
         MVC   W2L1,1(R3)          Copy op2 value to work
         LA    R5,W1L3             R5 --> result
         LA    R6,L'W1L3-1         R6  =  len code of result
         MP    W1L3,W2L1           Do the multiplication
         B     T03MulCR            Check the result
T03Mul_7_3     DS    0H
         MVC   W1L7,1(R2)          Copy op1 value to work
         MVC   W2L3,1(R3)          Copy op2 value to work
         LA    R5,W1L7             R5 --> result
         LA    R6,L'W1L7-1         R6  =  len code of result
         MP    W1L7,W2L3           Do the multiplication
         B     T03MulCR            Check the result
T03Mul_11_5    DS    0H
         MVC   W1L11,1(R2)         Copy op1 value to work
         MVC   W2L5,1(R3)          Copy op2 value to work
         LA    R5,W1L1             R5 --> result
         LA    R6,L'W1L1-1         R6  =  len code of result
         MP    W1L11,W2L5          Do the multiplication
         B     T03MulCR            Check the result
T03Mul_16_8    DS    0H
         MVC   W1L16,1(R2)         Copy op1 value to work
         MVC   W2L8,1(R3)          Copy op2 value to work
         LA    R5,W1L16            R5 --> result
         LA    R6,L'W1L16-1        R6  =  len code of result
         MP    W1L16,W2L8          Do the multiplication
         B     T03MulCR            Check the result
*
T03MulCR DS    0H
         LA    R15,4               Test failed; did not S0C7
         B     T03MulDone          Done
T03MulER DS    0H
         LA    R15,16              Invalid op1,op2 len code pair
         B     T03MulDone          Done
T03Mul0C7      DS    0H
         MVC   WActABCC,ESCOMP     Copy actual completion code
         SR    R15,R15             Test Successful; did S0C7
T03MulDone     DS    0H
         LTR   R15,R15             Abend and recovery?
         BZ    T03MulExit          Yes; just exit
         MVI   WErr,C'*'           No; set error indicator
T03MulExit     DS    0H
*
         LR    R2,R15              Save return code
         ESTAE 0                   Cancel ESTAE
         LR    R15,R2              Restore R15
*
         L     R13,4(,R13)         Caller's save area
         L     R14,12(,R13)        Restore caller's registers
         LM    R0,R12,20(R13)      ... except for R15
         BR    R14                 Return to caller
*
***********************************************************************
*        Convert byte X'op1LC || op2LC' to branch table index
***********************************************************************
T03TT    DC    256AL1(0)           Translate table
         ORG   T03TT+X'20'         op1 len code 2, op2 len code 0
         DC    AL1(1)
         ORG   T03TT+X'62'         op1 len code 6, op2 len code 2
         DC    AL1(2)
         ORG   T03TT+X'A4'         op1 len code 10, op2 len code 4
         DC    AL1(3)
         ORG   T03TT+X'F7'         op1 len code 15, op2 len code 7
         DC    AL1(4)
         ORG   ,
*
         LTORG
*
***********************************************************************
*        Parameter lists for all tests
***********************************************************************
*
MP3PLP   DC   A(MP3PLP1,16,MP3PLPN)    1st plist, len 1, last plist
*
MP3PLP1  DS   0A                       first parameter list
***********************************************************************
*
*        op1 len 3 * op2 len 1
*
         DC    A(MP3_OP1_L3_V_1)           op1 value
         DC    A(MP3_OP2_L1_V_1)           op2 value
         DC    A(MP3EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP3_OP1_L3_V_2)           op1 value
         DC    A(MP3_OP2_L1_V_1)           op2 value
         DC    A(MP3EV000)                 expected product
         DC    A(0)                        expected CC
*
***********************************************************************
*
*        op1 len 7 * op2 len 3
*
         DC    A(MP3_OP1_L7_V_1)           op1 value
         DC    A(MP3_OP2_L3_V_1)           op2 value
         DC    A(MP3EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP3_OP1_L7_V_2)           op1 value
         DC    A(MP3_OP2_L3_V_1)           op2 value
         DC    A(MP3EV000)                 expected product
         DC    A(0)                        expected CC
*
***********************************************************************
*
*        op1 len 11 * op2 len 7
*
         DC    A(MP3_OP1_L11_V_1)          op1 value
         DC    A(MP3_OP2_L5_V_1)           op2 value
         DC    A(MP3EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP3_OP1_L11_V_2)          op1 value
         DC    A(MP3_OP2_L5_V_1)           op2 value
         DC    A(MP3EV000)                 expected product
         DC    A(0)                        expected CC
*
***********************************************************************
*
*        op1 len 16 * op2 len 8
*
         DC    A(MP3_OP1_L16_V_1)          op1 value
         DC    A(MP3_OP2_L8_V_1)           op2 value
         DC    A(MP3EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP3_OP1_L16_V_2)          op1 value
         DC    A(MP3_OP2_L8_V_1)           op2 value
         DC    A(MP3EV000)                 expected product
         DC    A(0)                        expected CC
*
MP3PLPN  EQU   *-16,16                     Last parameter


***********************************************************************
*        Values for op1 and op2
***********************************************************************
*
MP3_OP1_L3_V_1   DS    0X                  op1 len 3
                 DC    AL1(3-1)            Length code
                 DC    XL3'01000C'         Value
*
MP3_OP1_L3_V_2   DS    0X                  op1 len 3
                 DC    AL1(3-1)            Length code
                 DC    XL3'10000C'         Value
*
MP3_OP2_L1_V_1   DS    0X                  op2 len 1
                 DC    AL1(1-1)            Length code
                 DC    XL1'1C'             Value
*
*----------------------------------------------------------------------
*
MP3_OP1_L7_V_1   DS    0X                  op1 len 7
                 DC    AL1(7-1)            Length code
                 DC    XL7'0000010000000C' Value
*
MP3_OP1_L7_V_2   DS    0X                  op1 len 7
                 DC    AL1(7-1)            Length code
                 DC    XL7'1000000000000C' Value
*
MP3_OP2_L3_V_1   DS    0X                  op2 len 3
                 DC    AL1(3-1)            Length code
                 DC    XL3'00001C'         Value
*
*----------------------------------------------------------------------
*
MP3_OP1_L11_V_1  DS   0X                   op1 len 11
                 DC    AL1(11-1)           Length code
                 DC    XL11'000000000100000000000C'    Value
*
MP3_OP1_L11_V_2  DS   0X                   op1 len 11
                 DC    AL1(11-1)           Length code
                 DC    XL11'100000000000000000000C'    Value
*
MP3_OP2_L5_V_1   DS    0X                  op2 len 7
                 DC    AL1(5-1)            Length code
                 DC    XL5'000000001C'     Value
*
*----------------------------------------------------------------------
*
MP3_OP1_L16_V_1  DS   0X                   op1 len 16
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000001000000000000000C'  Value
*
MP3_OP1_L16_V_2  DS   0X                   op1 len 16
                 DC    AL1(16-1)           Length code
                 DC    XL16'1000000000000000000000000000000C'  Value
*
MP3_OP2_L8_V_1   DS    0X                  op2 len 8
                 DC    AL1(8-1)            Length code
                 DC    XL8'000000000000001C'   Value
*
***********************************************************************
*
***********************************************************************
*        Expected values
***********************************************************************
*
MP3EV000 DC    XL16'0C'
*
         DROP  R11,R12             End addressability
*
***********************************************************************
*
* Routine: T04
*
*        MP   op1,op2  invalid data in op1 or op2.
*
*        All should have a data exception (S0C7).
*
*        A successful test is one that results in a data exception.
*
*        Four tests, each with seven cases. See following table.
*
*            op1 len    op2 len    op1 op2 values good or bad
*            -------    -------    --------------------------
*               1          1       3 op1 bad, op2 good
*                                  3 op1 good, op2 bad
*                                  1 op1 bad, op2 bad
*               5          5       3 op1 bad, op2 good
*                                  3 op1 good, op2 bad
*                                  1 op1 bad, op2 bad
*               9          9       3 op1 bad, op2 good
*                                  3 op1 good, op2 bad
*                                  1 op1 bad, op2 bad
*              16         16       3 op1 bad, op2 good
*                                  3 op1 good, op2 bad
*                                  1 op1 bad, op2 bad
*
*        Total number of test cases = 4 * 7 = 28.
*
*        Total number of failures, total number of successes,
*        stored in common storage fields MP04#F, MP04#S,
*        respectively.
*
***********************************************************************
*
         Using Data,R11            R11 --> data always
T04      DS    0H
         STM   R14,R12,12(R13)     Save caller's registers
         L     R13,8(,R13)         Next save area
         LR    R12,R15             R12 = base register
         USING T04,R12             Establish addressability
*
         LM    R1,R3,MP4PLP        R1 --> 1st parameter list
*                                  R2  =  len one parameter list
*                                  R3 --> last parameter list
*
         SR    R9,R9               R9 = number of tests that fail
         LR    R10,R9              R10 = number of tests that succeed
*
         MVI   WT#,C'4'            Test number for print
*
         MVI   WExpABCC,X'00'      Abends are expected
*
T04100   DS    0H
         BAS   R14,T04Mul          Perform one multiplication
         LTR   R15,R15             Test successful?
         BZ    T04200              Yes; count success
         AHI   R9,1                No; count failure
         B     T04300              Continue
T04200   DS    0H
         AHI   R10,1               Count success
T04300   DS    0H
         LARL  R15,PrtRes          Print routine
         BASR  R14,R15             Print results
         BXLE  R1,R2,T04100        Process all parameter lists
*
         STM   R9,R10,MP04ST       Save # failures, # successes
*
         L     R13,4(,R13)         Caller's save area
         LM    R14,R12,12(R13)     Restore caller's registers
         BR    R14                 Return to caller
*
***********************************************************************
*
* Routine: T04Mul
*
*        Perform one MP test
*
*        The MP is expected to result in a data exception (S0C7).
*        An ESTAE is created to trap the abend and retry to indicate
*        that the test is successful.
*
*        Input:
*
*            R1 --> parameter list
*                   +0 --> value for op1; 1st byte len code
*                   +4 --> value for op2; 1st byte len code
*                   +8 --> expected product; 16 bytes; no len code
*                   +C  =  expected CC
*
*        Note: the 3rd and 4th parameters are not used since the
*              MP is expected to result in a data exception.
*
*        Output:
*
*            WErr    report error indicator; ' ' no error; '*' error
*
*            WCC     condition code after instruction executed
*                    X'FF' in leftmost byte if instruction not executed
*
*            WResult set to result; left-justified in 16-byte field
*                    X'FF' in leftmost byte if instruction not executed
*
*            WActABCC set to abend completion code if abend occurs;
*                     zeros if no abend
*
*            WExpABCC set to expected abend completion code
*
*        Return code:  0 test succeeded
*                      4 test failed
*                     16 op1,op2 length code pair invalid
*
***********************************************************************
*
T04Mul   DS    0H
         STM   R14,R12,12(R13)     Save caller's registers
*
         LA    R3,ESPARM           Parm list for ESTAE exit
         MVI   ESF1,ESF10C7        Initialize ESTAE flag
         LA    R0,T04Mul0C7        Retry address
         ST    R0,ESRET@           Save in ESTAE parm list
         LARL  R4,ESTAEEX          ESTAE exit
         ESTAE (R4),PARAM=(R3)     Set ESTAE
*
         L     R1,24(,R13)         Restore R1
*
         L     R13,8(,R13)         Next save area
*
         LM    R2,R3,0(R1)         R2 --> op1 value
*                                  R3 --> op2 value
*
*        Note: third and fourth parameters not used!
*
         MVI   WErr,C' '           No failure
         MVI   WCC,X'FF'           No CC; instruction not executed
         MVI   WResult,X'FF'       No result; instruction not executed
*
         XC    WActABCC,WActABCC   No completion code yet
         MVC   WExpABCC,ABCC0C7    Copy expected completion code
*
         SR    R5,R5               Prepare to get op1 len code
         SR    R6,R6               Prepare to get op2 len code
         IC    R5,0(,R2)           op1 len code; 0 - 15
         SLL   R5,4                Move left one nibble
         IC    R6,0(,R3)           op2 len code; 0 - 15
         OR    R5,R6               R5 = op1LC || op2LC
         IC    R5,T04TT(R5)        Get branch table index
         SLL   R5,2                Convert to offset
         TM    *,X'91'             Set CC 3
         B     T04MulBT(R5)        Branch to appropriate code
T04MulBT DS    0H
         B     T04MulER            Skip; invalid (op1 len, op2 len)
         B     T04Mul_3_1          op1 len 3, op2 len 1
         B     T04Mul_7_3          op1 len 7, op2 len 5
         B     T04Mul_11_5         op1 len 10, op2 len 5
         B     T04Mul_16_8         op1 len 16, op2 len 8
*
T04Mul_3_1     DS    0H
         MVC   W1L3,1(R2)          Copy op1 value to work
         MVC   W2L1,1(R3)          Copy op2 value to work
         LA    R5,W1L3             R5 --> result
         LA    R6,L'W1L3-1         R6  =  len code of result
         MP    W1L3,W2L1           Do the multiplication
         B     T04MulCR            Check the result
T04Mul_7_3     DS    0H
         MVC   W1L7,1(R2)          Copy op1 value to work
         MVC   W2L3,1(R3)          Copy op2 value to work
         LA    R5,W1L7             R5 --> result
         LA    R6,L'W1L7-1         R6  =  len code of result
         MP    W1L7,W2L3           Do the multiplication
         B     T04MulCR            Check the result
T04Mul_11_5    DS    0H
         MVC   W1L11,1(R2)         Copy op1 value to work
         MVC   W2L5,1(R3)          Copy op2 value to work
         LA    R5,W1L1             R5 --> result
         LA    R6,L'W1L1-1         R6  =  len code of result
         MP    W1L11,W2L5          Do the multiplication
         B     T04MulCR            Check the result
T04Mul_16_8    DS    0H
         MVC   W1L16,1(R2)         Copy op1 value to work
         MVC   W2L8,1(R3)          Copy op2 value to work
         LA    R5,W1L16            R5 --> result
         LA    R6,L'W1L16-1        R6  =  len code of result
         MP    W1L16,W2L8          Do the multiplication
         B     T04MulCR            Check the result
*
T04MulCR DS    0H
         LA    R15,4               Test failed; did not S0C7
         B     T04MulDone          Done
T04MulER DS    0H
         LA    R15,16              Invalid op1,op2 len code pair
         B     T04MulDone          Done
T04Mul0C7      DS    0H
         MVC   WActABCC,ESCOMP     Copy actual completion code
         SR    R15,R15             Test Successful; did S0C7
T04MulDone     DS    0H
         LTR   R15,R15             Abend and recovery?
         BZ    T04MulExit          Yes; just exit
         MVI   WErr,C'*'           No; set error indicator
T04MulExit     DS    0H
*
         LR    R2,R15              Save return code
         ESTAE 0                   Cancel ESTAE
         LR    R15,R2              Restore R15
*
         L     R13,4(,R13)         Caller's save area
         L     R14,12(,R13)        Restore caller's registers
         LM    R0,R12,20(R13)      ... except for R15
         BR    R14                 Return to caller
*
***********************************************************************
*        Convert byte X'op1LC || op2LC' to branch table index
***********************************************************************
T04TT    DC    256AL1(0)           Translate table
         ORG   T04TT+X'20'         op1 len code 2, op2 len code 0
         DC    AL1(1)
         ORG   T04TT+X'62'         op1 len code 6, op2 len code 2
         DC    AL1(2)
         ORG   T04TT+X'A4'         op1 len code 10, op2 len code 4
         DC    AL1(3)
         ORG   T04TT+X'F7'         op1 len code 15, op2 len code 7
         DC    AL1(4)
         ORG   ,
*
         LTORG
*
***********************************************************************
*        Parameter lists for all tests
***********************************************************************
*
MP4PLP   DC   A(MP4PLP1,16,MP4PLPN)    1st plist, len 1, last plist
*
MP4PLP1  DS   0A                       first parameter list
***********************************************************************
*
*        op1 len 3 * op2 len 1
*
         DC    A(MP4_OP1_L3_V_B_1)         op1 value
         DC    A(MP4_OP2_L1_V_G_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L3_V_B_2)         op1 value
         DC    A(MP4_OP2_L1_V_G_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L3_V_B_3)         op1 value
         DC    A(MP4_OP2_L1_V_G_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L3_V_G_1)         op1 value
         DC    A(MP4_OP2_L1_V_B_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L3_V_G_1)         op1 value
         DC    A(MP4_OP2_L1_V_B_2)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L3_V_G_1)         op1 value
         DC    A(MP4_OP2_L1_V_B_3)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L3_V_B_1)         op1 value
         DC    A(MP4_OP2_L1_V_B_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
***********************************************************************
*
*        op1 len 7 * op2 len 3
*
         DC    A(MP4_OP1_L7_V_B_1)         op1 value
         DC    A(MP4_OP2_L3_V_G_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L7_V_B_2)         op1 value
         DC    A(MP4_OP2_L3_V_G_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L7_V_B_3)         op1 value
         DC    A(MP4_OP2_L3_V_G_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L7_V_G_1)         op1 value
         DC    A(MP4_OP2_L3_V_B_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L7_V_G_1)         op1 value
         DC    A(MP4_OP2_L3_V_B_2)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L7_V_G_1)         op1 value
         DC    A(MP4_OP2_L3_V_B_3)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L7_V_B_1)         op1 value
         DC    A(MP4_OP2_L3_V_B_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
***********************************************************************
*
*        op1 len 11 * op2 len 7
*
         DC    A(MP4_OP1_L11_V_B_1)        op1 value
         DC    A(MP4_OP2_L5_V_G_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L11_V_B_2)        op1 value
         DC    A(MP4_OP2_L5_V_G_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L11_V_B_3)        op1 value
         DC    A(MP4_OP2_L5_V_G_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L11_V_G_1)        op1 value
         DC    A(MP4_OP2_L5_V_B_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L11_V_G_1)        op1 value
         DC    A(MP4_OP2_L5_V_B_2)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L11_V_G_1)        op1 value
         DC    A(MP4_OP2_L5_V_B_3)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L11_V_B_1)        op1 value
         DC    A(MP4_OP2_L5_V_B_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
***********************************************************************
*
*        op1 len 16 * op2 len 8
*
         DC    A(MP4_OP1_L16_V_B_1)        op1 value
         DC    A(MP4_OP2_L8_V_G_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L16_V_B_2)        op1 value
         DC    A(MP4_OP2_L8_V_G_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L16_V_B_3)        op1 value
         DC    A(MP4_OP2_L8_V_G_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L16_V_G_1)        op1 value
         DC    A(MP4_OP2_L8_V_B_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L16_V_G_1)        op1 value
         DC    A(MP4_OP2_L8_V_B_2)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L16_V_G_1)        op1 value
         DC    A(MP4_OP2_L8_V_B_3)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
         DC    A(MP4_OP1_L16_V_B_1)        op1 value
         DC    A(MP4_OP2_L8_V_B_1)         op2 value
         DC    A(MP4EV000)                 expected product
         DC    A(0)                        expected CC
*
MP4PLPN  EQU   *-16,16                     Last parameter

***********************************************************************
*        Values for op1 and op2
***********************************************************************
*
MP4_OP1_L3_V_B_1 DS    0X                  op1 len 3 bad value
                 DC    AL1(3-1)            Length code
                 DC    XL3'50'             Value
*
MP4_OP1_L3_V_B_2 DS    0X                  op1 len 3 bad value
                 DC    AL1(3-1)            Length code
                 DC    XL3'AD'             Value
*
MP4_OP1_L3_V_B_3 DS    0X                  op1 len 3 bad value
                 DC    AL1(3-1)            Length code
                 DC    XL3'A0'             Value
*
MP4_OP1_L3_V_G_1 DS    0X                  op1 len 3 good value
                 DC    AL1(3-1)            Length code
                 DC    XL3'5C'             Value
*
MP4_OP2_L1_V_B_1 DS    0X                  op2 len 1 bad value
                 DC    AL1(1-1)            Length code
                 DC    XL1'61'             Value
*
MP4_OP2_L1_V_B_2 DS    0X                  op2 len 1 bad value
                 DC    AL1(1-1)            Length code
                 DC    XL1'BC'             Value
*
MP4_OP2_L1_V_B_3 DS    0X                  op2 len 1 bad value
                 DC    AL1(1-1)            Length code
                 DC    XL1'B1'             Value
*
MP4_OP2_L1_V_G_1 DS    0X                  op2 len 1 good value
                 DC    AL1(1-1)            Length code
                 DC    XL1'6C'             Value
*
***********************************************************************
MP4_OP1_L7_V_B_1 DS    0X                  op1 len 7 bad value
                 DC    AL1(7-1)            Length code
                 DC    XL7'5000000000'     Value
*
MP4_OP1_L7_V_B_2 DS    0X                  op1 len 7 bad value
                 DC    AL1(7-1)            Length code
                 DC    XL7'5A0A0A0A0D'     Value
*
MP4_OP1_L7_V_B_3 DS    0X                  op1 len 7 bad value
                 DC    AL1(7-1)            Length code
                 DC    XL7'ABCDEFABC0'     Value
*
MP4_OP1_L7_V_G_1 DS    0X                  op1 len 7 good value
                 DC    AL1(7-1)            Length code
                 DC    XL7'500000000C'     Value
*
MP4_OP2_L3_V_B_1 DS    0X                  op2 len 3 bad value
                 DC    AL1(3-1)            Length code
                 DC    XL3'6000000001'     Value
*
MP4_OP2_L3_V_B_2 DS    0X                  op2 len 3 bad value
                 DC    AL1(3-1)            Length code
                 DC    XL3'60B0D0B00C'     Value
*
MP4_OP2_L3_V_B_3 DS    0X                  op2 len 3 bad value
                 DC    AL1(3-1)            Length code
                 DC    XL3'FEDCBAFED1'     Value
*
MP4_OP2_L3_V_G_1 DS    0X                  op2 len 3 good value
                 DC    AL1(3-1)            Length code
                 DC    XL3'600000000C'     Value
*
***********************************************************************
MP4_OP1_L11_V_B_1 DS    0X                  op1 len 11 bad value
                 DC    AL1(11-1)            Length code
                 DC    XL11'0000000000000050000000' Value
*
MP4_OP1_L11_V_B_2 DS    0X                  op1 len 11 bad value
                 DC    AL1(11-1)            Length code
                 DC    XL11'000000000000005A0A0A0D' Value
*
MP4_OP1_L11_V_B_3 DS    0X                  op1 len 11 bad value
                 DC    AL1(11-1)            Length code
                 DC    XL11'00000000000000ABCDEFA0' Value
*
MP4_OP1_L11_V_G_1 DS    0X                  op1 len 11 good value
                 DC    AL1(11-1)            Length code
                 DC    XL11'000000000000005000000C' Value
*
MP4_OP2_L5_V_B_1 DS    0X                  op2 len 5 bad value
                 DC    AL1(5-1)            Length code
                 DC    XL5'6000000001'     Value
*
MP4_OP2_L5_V_B_2 DS    0X                  op2 len 5 bad value
                 DC    AL1(5-1)            Length code
                 DC    XL5'60B0D0B0BC'     Value
*
MP4_OP2_L5_V_B_3 DS    0X                  op2 len 5 bad value
                 DC    AL1(5-1)            Length code
                 DC    XL5'FEDCBAFED1'     Value
*
MP4_OP2_L5_V_G_1 DS    0X                  op2 len 5 good value
                 DC    AL1(5-1)            Length code
                 DC    XL5'600000000C'     Value
*
***********************************************************************
MP4_OP1_L16_V_B_1 DS   0X                  op1 len 16 bad value
                 DC    AL1(16-1)           Length code
                 DC    XL16'00000000000000000000000000000000'  Value
*
MP4_OP1_L16_V_B_2 DS   0X                  op1 len 16 bad value
                 DC    AL1(16-1)           Length code
                 DC    XL16'00000000000000000000000A0A0A0A0D'  Value
*
MP4_OP1_L16_V_B_3 DS   0X                  op1 len 16 bad value
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000000000ABCDEFABC0'  Value
*
MP4_OP1_L16_V_G_1 DS   0X                  op1 len 16 good value
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000000000500000000C'  Value
*
MP4_OP2_L8_V_B_1 DS    0X                  op2 len 11 bad value
                 DC    AL1(8-1)            Length code
                 DC    XL8'6000000000000001'   Value
*
MP4_OP2_L8_V_B_2 DS    0X                  op2 len 11 bad value
                 DC    AL1(8-1)            Length code
                 DC    XL8'60B0B0B0B0B0B0BC'   Value
*
MP4_OP2_L8_V_B_3 DS    0X                  op2 len 11 bad value
                 DC    AL1(8-1)            Length code
                 DC    XL8'FEDCBAFEDCBAFED1'   Value
*
MP4_OP2_L8_V_G_1 DS    0X                  op2 len 11 good value
                 DC    AL1(8-1)            Length code
                 DC    XL8'600000000000000C'   Value
*
***********************************************************************
*        Expected values
***********************************************************************
*
MP4EV000 DC    XL16'0C'
*
         DROP  R11,R12             End addressability
*
***********************************************************************
*
* Routine: T05
*
*        MP   op1,op2  op2 too long or op2 len > op1 len.
*
*        All tests should result in a specification exception (S0C6).
*
*        A successful test is one that results in a specification
*        exception.
*
*        Four tests, each with two cases. See following table.
*
*            op1 len    op2 len
*            -------    -------
*               3        3,4,9
*               7        7,8,9
*              11          9
*              16          9
*
*        Total number of test cases = 3 + 3 + 1 + 1 = 8.
*
*        Total number of failures, total number of successes,
*        stored in common storage fields MP05#F, MP05#S,
*        respectively.
*
***********************************************************************
*
         Using Data,R11            R11 --> data always
T05      DS    0H
         STM   R14,R12,12(R13)     Save caller's registers
         L     R13,8(,R13)         Next save area
         LR    R12,R15             R12 = base register
         USING T05,R12             Establish addressability
*
         LM    R1,R3,MP5PLP        R1 --> 1st parameter list
*                                  R2  =  len one parameter list
*                                  R3 --> last parameter list
*
         SR    R9,R9               R9 = number of tests that fail
         LR    R10,R9              R10 = number of tests that succeed
*
         MVI   WT#,C'5'            Test number for print
*
         MVI   WExpABCC,X'00'      Abends are expected
*
T05100   DS    0H
         BAS   R14,T05Mul          Perform one multiplication
         LTR   R15,R15             Test successful?
         BZ    T05200              Yes; count success
         AHI   R9,1                No; count failure
         B     T05300              Continue
T05200   DS    0H
         AHI   R10,1               Count success
T05300   DS    0H
         LARL  R15,PrtRes          Print routine
         BASR  R14,R15             Print results
         BXLE  R1,R2,T05100        Process all parameter lists
*
         STM   R9,R10,MP05ST       Save # failures, # successes
*
         L     R13,4(,R13)         Caller's save area
         LM    R14,R12,12(R13)     Restore caller's registers
         BR    R14                 Return to caller
*
***********************************************************************
*
* Routine: T05Mul
*
*        Perform one MP test
*
*        The MP is expected to result in a specification
*        exception (S0C6). An ESTAE is created to trap the
*        abend and retry to indicate that the test is successful.
*
*        Input:
*
*            R1 --> parameter list
*                   +0 --> value for op1; 1st byte len code
*                   +4 --> value for op2; 1st byte len code
*                   +8 --> expected product; 16 bytes; no len code
*                   +C  =  expected CC
*
*        Note: the 3rd and 4th parameters are not used since the
*              MP is expected to result in a specification exception.
*
*        Output:
*
*            WErr    report error indicator; ' ' no error; '*' error
*
*            WCC     condition code after instruction executed
*                    X'FF' in leftmost byte if instruction not executed
*
*            WResult set to result; left-justified in 16-byte field
*                    X'FF' in leftmost byte if instruction not executed
*
*            WActABCC set to abend completion code if abend occurs;
*                     zeros if no abend
*
*            WExpABCC set to expected abend completion code
*
*        Return code:  0 test succeeded
*                      4 test failed
*                     16 op1,op2 length code pair invalid
*
***********************************************************************
*
T05Mul   DS    0H
         STM   R14,R12,12(R13)     Save caller's registers
*
         LA    R3,ESPARM           Parm list for ESTAE exit
         MVI   ESF1,ESF10C6        Initialize ESTAE flag
*
*         OI    ESF1,ESF1DREG       Dump registers
*
         LA    R0,T05Mul0C6        Retry address
         ST    R0,ESRET@           Save in ESTAE parm list
         LARL  R4,ESTAEEX          ESTAE exit
         ESTAE (R4),PARAM=(R3)     Set ESTAE
*
         L     R1,24(,R13)         Restore R1
*
         L     R13,8(,R13)         Next save area
*
         LM    R2,R3,0(R1)         R2 --> op1 value
*                                  R3 --> op2 value
*
*        Note: third and fourth parameters not used!
*
         MVI   WErr,C' '           No failure
         MVI   WCC,X'FF'           No CC; instruction not executed
         MVI   WResult,X'FF'       No result; instruction not executed
*
         XC    WActABCC,WActABCC   No completion code yet
         MVC   WExpABCC,ABCC0C6    Copy expected completion code
*
         SR    R5,R5               Prepare to get op1 len code
         SR    R6,R6               Prepare to get op2 len code
         IC    R5,0(,R2)           op1 len code; 0 - 15
         SLL   R5,4                Move left one nibble
         IC    R6,0(,R3)           op2 len code; 0 - 15
         OR    R5,R6               R5 = op1LC || op2LC
         IC    R5,T05TT(R5)        Get branch table index
         SLL   R5,2                Convert to offset
         TM    *,X'91'             Set CC 3
         B     T05MulBT(R5)        Branch to appropriate code
T05MulBT DS    0H
         B     T05MulER            Skip; invalid (op1 len, op2 len)
         B     T05Mul_3_3          op1 len 3, op2 len 3
         B     T05Mul_3_4          op1 len 3, opw len 4
         B     T05Mul_3_9          op1 len 3, opw len 9
         B     T05Mul_7_7          op1 len 7, op2 len 7
         B     T05Mul_7_8          op1 len 7, op2 len 8
         B     T05Mul_7_9          op1 len 7, op2 len 9
         B     T05Mul_11_9         op1 len 11, op2 len 9
         B     T05Mul_16_9         op1 len 16, op2 len 9
*
T05Mul_3_3     DS    0H
         MVC   W1L3,1(R2)          Copy op1 value to work
         MVC   W2L3,1(R3)          Copy op2 value to work
         LA    R5,W1L3             R5 --> result
         LA    R6,L'W1L3-1         R6  =  len code of result
         MP    W1L3,W2L3           Do the multiplication
         B     T05MulCR            Check the result
T05Mul_3_4     DS    0H
         MVC   W1L3,1(R2)          Copy op1 value to work
         MVC   W2L4,1(R3)          Copy op2 value to work
         LA    R5,W1L3             R5 --> result
         LA    R6,L'W1L3-1         R6  =  len code of result
         MP    W1L3,W2L4           Do the multiplication
         B     T05MulCR            Check the result
T05Mul_3_9     DS    0H
         MVC   W1L3,1(R2)          Copy op1 value to work
         MVC   W2L9,1(R3)          Copy op2 value to work
         LA    R5,W1L3             R5 --> result
         LA    R6,L'W1L3-1         R6  =  len code of result
         MP    W1L3,W2L9           Do the multiplication
         B     T05MulCR            Check the result
T05Mul_7_7     DS    0H
         MVC   W1L7,1(R2)          Copy op1 value to work
         MVC   W2L7,1(R3)          Copy op2 value to work
         LA    R5,W1L7             R5 --> result
         LA    R6,L'W1L7-1         R6  =  len code of result
         MP    W1L7,W2L7           Do the multiplication
         B     T05MulCR            Check the result
T05Mul_7_8     DS    0H
         MVC   W1L7,1(R2)          Copy op1 value to work
         MVC   W2L8,1(R3)          Copy op2 value to work
         LA    R5,W1L7             R5 --> result
         LA    R6,L'W1L7-1         R6  =  len code of result
         MP    W1L7,W2L8           Do the multiplication
         B     T05MulCR            Check the result
T05Mul_7_9     DS    0H
         MVC   W1L7,1(R2)          Copy op1 value to work
         MVC   W2L9,1(R3)          Copy op2 value to work
         LA    R5,W1L7             R5 --> result
         LA    R6,L'W1L7-1         R6  =  len code of result
         MP    W1L7,W2L9           Do the multiplication
         B     T05MulCR            Check the result
T05Mul_11_9    DS    0H
         MVC   W1L11,1(R2)         Copy op1 value to work
         MVC   W2L9,1(R3)          Copy op2 value to work
         LA    R5,W1L1             R5 --> result
         LA    R6,L'W1L1-1         R6  =  len code of result
         MP    W1L11,W2L9          Do the multiplication
         B     T05MulCR            Check the result
T05Mul_16_9    DS    0H
         MVC   W1L16,1(R2)         Copy op1 value to work
         MVC   W2L9,1(R3)          Copy op2 value to work
         LA    R5,W1L16            R5 --> result
         LA    R6,L'W1L16-1        R6  =  len code of result
         MP    W1L16,W2L9          Do the multiplication
         B     T05MulCR            Check the result
*
T05MulCR DS    0H
         LA    R15,4               Did not S0C6; error
         B     T05MulDone          Done
T05MulER DS    0H
         LA    R15,16              Invalid op1,op2 len code pair
         B     T05MulDone          Done
T05Mul0C6      DS    0H
         MVC   WActABCC,ESCOMP     Copy actual completion code
         SR    R15,R15             Test Successful; did S0C6
T05MulDone     DS    0H
         LTR   R15,R15             Abend and recovery?
         BZ    T05MulExit          Yes; just exit
         MVI   WErr,C'*'           No; set error indicator
T05MulExit     DS    0H
*
         LR    R2,R15              Save return code
         ESTAE 0                   Cancel ESTAE
         LR    R15,R2              Restore R15
*
         L     R13,4(,R13)         Caller's save area
         L     R14,12(,R13)        Restore caller's registers
         LM    R0,R12,20(R13)      ... except for R15
         BR    R14                 Return to caller
*
***********************************************************************
*        Convert byte X'op1LC || op2LC' to branch table index
***********************************************************************
T05TT    DC    256AL1(0)           Translate table
         ORG   T05TT+X'22'         op1 len code 2, op2 len code 2
         DC    AL1(1)
         ORG   T05TT+X'23'         op1 len code 2, op2 len code 3
         DC    AL1(2)
         ORG   T05TT+X'28'         op1 len code 2, op2 len code 8
         DC    AL1(3)
*
         ORG   T05TT+X'66'         op1 len code 6, op2 len code 6
         DC    AL1(4)
         ORG   T05TT+X'67'         op1 len code 6, op2 len code 7
         DC    AL1(5)
         ORG   T05TT+X'68'         op1 len code 6, op2 len code 8
         DC    AL1(6)
*
         ORG   T05TT+X'A8'         op1 len code 10, op2 len code 8
         DC    AL1(7)
*)
         ORG   T05TT+X'F8'         op1 len code 15, op2 len code 8
         DC    AL1(8)
         ORG   ,
*
         LTORG
*
***********************************************************************
*        Parameter lists for all tests
***********************************************************************
*
MP5PLP   DC   A(MP5PLP1,16,MP5PLPN)    1st plist, len 1, last plist
*
MP5PLP1  DS   0A                       first parameter list
***********************************************************************
*
*        op1 len 3 * op2 len 3
*
         DC    A(MP5_OP1_L3_V_1)           op1 value
         DC    A(MP5_OP1_L3_V_1)           op2 value
         DC    A(MP5EV000)                 expected product
         DC    A(0)                        expected CC
*
*        op1 len 3 * op2 len 4
*
         DC    A(MP5_OP1_L3_V_1)           op1 value
         DC    A(MP5_OP2_L4_V_1)           op2 value
         DC    A(MP5EV000)                 expected product
         DC    A(0)                        expected CC
*
*        op1 len 3 * op2 len 9
*
         DC    A(MP5_OP1_L3_V_1)           op1 value
         DC    A(MP5_OP2_L9_V_1)           op2 value
         DC    A(MP5EV000)                 expected product
         DC    A(0)                        expected CC
*
***********************************************************************
*
*        op1 len 7 * op2 len 7
*
         DC    A(MP5_OP1_L7_V_1)           op1 value
         DC    A(MP5_OP1_L7_V_1)           op2 value
         DC    A(MP5EV000)                 expected product
         DC    A(0)                        expected CC
*
*        op1 len 7 * op2 len 8
*
         DC    A(MP5_OP1_L7_V_1)           op1 value
         DC    A(MP5_OP2_L8_V_1)           op2 value
         DC    A(MP5EV000)                 expected product
         DC    A(0)                        expected CC
*
*        op1 len 7 * op2 len 9
*
         DC    A(MP5_OP1_L7_V_1)           op1 value
         DC    A(MP5_OP2_L9_V_1)           op2 value
         DC    A(MP5EV000)                 expected product
         DC    A(0)                        expected CC
*
***********************************************************************
*
*        op1 len 11 * op2 len 9
*
         DC    A(MP5_OP1_L11_V_1)          op1 value
         DC    A(MP5_OP2_L9_V_1)           op2 value
         DC    A(MP5EV000)                 expected product
         DC    A(0)                        expected CC
*
***********************************************************************
*
*        op1 len 16 * op2 len 9
*
         DC    A(MP5_OP1_L16_V_1)          op1 value
         DC    A(MP5_OP2_L9_V_1)           op2 value
         DC    A(MP5EV000)                 expected product
         DC    A(0)                        expected CC
*
MP5PLPN  EQU   *-16,16                     Last parameter


***********************************************************************
*        Values for op1 and op2
***********************************************************************
*
MP5_OP1_L3_V_1   DS    0X                  op1 len 3
                 DC    AL1(3-1)            Length code
                 DC    XL3'00001C'         Value
*
MP5_OP2_L4_V_1   DS    0X                  op2 len 4
                 DC    AL1(4-1)            Length code
                 DC    XL4'1C'             Value
*
*----------------------------------------------------------------------
*
MP5_OP1_L7_V_1   DS    0X                  op1 len 7
                 DC    AL1(7-1)            Length code
                 DC    XL7'0000000000001C' Value
*
MP5_OP2_L8_V_1   DS    0X                  op2 len 8
                 DC    AL1(8-1)            Length code
                 DC    XL8'1C'             Value
*
MP5_OP2_L9_V_1   DS    0X                  op2 len 9
                 DC    AL1(9-1)            Length code
                 DC    XL9'1C'             Value
*
*----------------------------------------------------------------------
*
MP5_OP1_L11_V_1  DS   0X                   op1 len 11
                 DC    AL1(11-1)           Length code
                 DC    XL11'000000000000000000001C'    Value
*
*----------------------------------------------------------------------
*
MP5_OP1_L16_V_1  DS   0X                   op1 len 16
                 DC    AL1(16-1)           Length code
                 DC    XL16'0000000000000000000000000000001C'  Value
*
***********************************************************************
*
***********************************************************************
*        Expected values
***********************************************************************
*
MP5EV000 DC    XL16'0C'
*
         DROP  R11,R12             End addressability
*
         Title 'ESTAE Exit'
***********************************************************************
*        ESTAE exit
*
*        Retry for S0C6, S0C7; continue termination otherwise
***********************************************************************
ESTAEEX  DS    0H
         USING ESTAEEX,R15         Establish addressability
         USING SDWA,R1             Overlay SDWA
         L     R2,SDWAPARM         ESTAE Parm list
         LM    R2,R4,0(R2)         R2: A(return address)
*                                  R3: word for completion code
*                                  R4: A(flags for ESTAE)
         L     R0,0(,R2)           Return address
         L     R5,SDWAABCC         Completion code
         ST    R5,0(,R3)           Return the completion code
***********************************************************************
* Note: completion code was X'000000Cx' - should be X'000Cx000'
*
* Note: ESTAE exit not driven when ABEND 100,DUMP issued???
*
* Note: Setting R15 = 0 at exit (no retry) resulted in recursive
*       calls to the exit for S0C1 abends!
*
* Check on these later.
***********************************************************************
*
         TM    0(R4),ESF1DREG      Dump Registers?
         BZ    EXNODREG            No
         LG    R8,SDWAEC1          EC PSW at error
         XDUMP ,                   Show values
EXNODREG DS    0H
*
         LA    R2,4                Assume retry
         TM    0(R4),ESF10C6       Monitoring S0C6?
         BZ    EX10                No; check next
         CHI   R5,X'00C6'          One we're checking?
         BE    EX100               Yes: retry
EX10     DS    0H
         TM    0(R4),ESF10C7       Monitoring S0C7?
         BZ    EX20                No; check next
         CHI   R5,X'00C7'          One we're checking?
         BE    EX100               Yes: retry
EX20     DS    0H
         SR    R2,R2               Do not retry
         B     EX100               Exit
EX100    DS    0H
         SETRP ,
         LR    R15,R2              4: Retry, 0: no retry
         BR    R14                 Return to operating system
*
         LTORG
*
         DROP  R15                 End ESTAE exit addressability
***********************************************************************
*        End ESTAE exit
***********************************************************************
*
         TITLE 'Print routines'
*
***********************************************************************
*
* Routine: PrtRes 
*
*        Print result of instruction execution
*
*        Input:
*
*          WRptType Report type; C'A' = all; C'S' = summary
*          WT#      Test number; C'1' - C'9'
*          WErr     Error indicator; C' ' or C'*'
*          WCC      Condition code after instruction; fullword;
*                   X'FF' in leftmost byte if not applicable
*          WResult  Result of instruction; 16 bytes;
*                   X'FF' in leftmost byte if not applicable
*          WActABCC Actual abend completion code when abend expected;
*                   fullword; unpredictable if no abend expected
*          WExpABCC Expected abend completion code; fullword;
*                   X'FF' in leftmost byte if no abend expected
*
*          R11 -->  Data area
*
*          R1 --> Parameter list for instruction execution
*                 +0 --> operand 1 value
*                 +4 --> operand 2 value
*                 +8 --> expected result
*                 +C  =  expected condition code
*
***********************************************************************
*    
         USING Data,R11            Overlay data area
*
PrtRes   DS    0H
         STM   R14,R12,12(R13)     Save caller's registers
         LR    R12,R15             R12 = base register
         USING PrtRes,R12          Establish addressability
*
         CLI   WRptType,C'A'       Print all data?
         BNE   PRExit              No; nothing to do here
*
         LM    R2,R5,0(R1)         R2 --> op1 value
*                                  R3 --> op2 value
*                                  R4 --> expected product; 16 bytes
*                                  R5  =  expected CC
*
         MVC   W1T#,WT#            Test number
         MVC   W1Err,WErr          Copy error indicator
*
         MVC   W1Mpcnd,Spaces      Initialize multiplicand to spaces
         MVC   W1Mplr,Spaces       Also multiplier
*
         SR    R7,R7               Prepare to get length code
         IC    R7,0(R2)            Length code of operand 1 (0-15)
*
         LA    R15,1(,R2)          R15 --> op1 value
         EX    R7,PRMVC            Copy op1 value to work area
         UNPK  DW(9),WK16(5)       Convert to printable hex
         UNPK  DW+8(9),WK16+4(5)   ... continue conversion
         UNPK  DW+16(9),WK16+8(5)  ... continue conversion
         UNPK  DW+24(9),WK16+12(5) ... continue conversion
         TR    DW(32),H2P2         Finish converison
*
         LA    R7,1(R7,R7)         Length code of printable hex
         LA    R14,W1Mpcnd+L'W1Mpcnd-1 Last byte of destination
         SR    R14,R7              Right-justified position
         LA    R15,DW              Source
         EX    R7,PRMVC2           Copy printable hex to print line
*
         SR    R7,R7               Prepare to get length code
         IC    R7,0(R3)            Length code of operand 2 (0-7)
*
         LA    R15,1(,R3)          R15 --> op2 value
         EX    R7,PRMVC            Copy op2 value to work area
         UNPK  DW(9),WK16(5)       Convert to printable hex
         UNPK  DW+8(9),WK16+4(5)   ... continue conversion
         UNPK  DW+16(9),WK16+8(5)  ... continue conversion
         UNPK  DW+24(9),WK16+12(5) ... continue conversion
         TR    DW(32),H2P2         Finish converison
*
         LA    R7,1(R7,R7)         Length code of printable hex
         LA    R14,W1Mplr          Destination (left-justified)
         LA    R15,DW              Source
         EX    R7,PRMVC2           Copy printable hex to print line
*
         WTO   MF=(E,WTO1)         First line of report sequence
*
         CLI   WResult,X'FF'       Was instruction executed?
         BE    PR100               No; skip print of line 2
*
         MVC   W2AAns,Spaces       Initialize actual answer to spaces
         MVC   W2EAns,Spaces       Also expected answer
         MVC   W2ELit,Spaces       Also error message area
*
         SR    R7,R7               Prepare to get length code
         IC    R7,0(R2)            Length code of operand 1 (0-15)
*
         LA    R15,WResult         R15 --> actual result
         EX    R7,PRMVC            Copy result to work area
         UNPK  DW(9),WK16(5)       Convert to printable hex
         UNPK  DW+8(9),WK16+4(5)   ... continue conversion
         UNPK  DW+16(9),WK16+8(5)  ... continue conversion
         UNPK  DW+24(9),WK16+12(5) ... continue conversion
         TR    DW(32),H2P2         Finish converison
*
         LA    R7,1(R7,R7)         Length code of printable hex
         LA    R14,W2AAns          Destination
         LA    R15,DW              Source
         EX    R7,PRMVC2           Copy printable hex to print line
*
         SR    R7,R7               Prepare to get length code
         IC    R7,0(R2)            Length code of operand 1 (0-15)
*
         LA    R15,15(,R4)         R15 --> last byte of expected result
         SR    R15,R7              R15 --> expected result
         EX    R7,PRMVC            Copy result to work area
         UNPK  DW(9),WK16(5)       Convert to printable hex
         UNPK  DW+8(9),WK16+4(5)   ... continue conversion
         UNPK  DW+16(9),WK16+8(5)  ... continue conversion
         UNPK  DW+24(9),WK16+12(5) ... continue conversion
         TR    DW(32),H2P2         Finish converison
*
         LA    R7,1(R7,R7)         Length code of printable hex
         LA    R14,W2EAns          Destination
         LA    R15,DW              Source
         EX    R7,PRMVC2           Copy printable hex to print line
*
         WTO   MF=(E,WTO2)         Second line of report sequence
*
PR100    DS    0H
         CLI   WCC,X'FF'           Was instruction executed?
         BE    PR200               No; skip print of line 3
         MVC   W3ELit,Spaces       Initialize error message to spaces
         MVC   W3ACC,WCC+3         Copy actual CC
         OI    W3ACC,X'F0'         Make printable
         STC   R5,W3ECC            Expected CC
         OI    W3ECC,X'F0'         Make printable
*
         WTO   MF=(E,WTO3)         Third line of report sequence
*
PR200    DS    0H
         CLI   WExpABCC,X'FF'      Abend expected?
         BE    PR300               No; skip print of abend codes
         MVC   W4ELit,Spaces       Initialize error message to spaces
         UNPK  DW(9),WActABCC(5)   Convert actual ABCC
         TR    DW,H2P2             ... to printable hex
         MVC   W4AABCC,DW          Copy to print line
         UNPK  DW(9),WExpABCC(5)   Convert expected ABCC
         TR    DW,H2P2             ... to printable hex
         MVC   W4EABCC,DW          Copy to print line
*
         WTO   MF=(E,WTO4)         Third line of report sequence
*
PR300    DS    0H
PRExit   DS    0H
         LM    R14,R12,12(R13)     Restore caller's registers
         BR    R14                 Return to caller
PRMVC    MVC   WK16(*-*),0(R15)    Copy value to work area
PRMVC2   MVC   0(*-*,R14),0(R15)   Copy source to destination
*
         DROP  R11,R12             End addressability
*
***********************************************************************
*
* Routine: PrtTot
*
*        Print totals for all tests
*
***********************************************************************
*
         USING Data,R11            Overlay data area
PrtTot   DS    0H
         STM   R14,R12,12(R13)     Save caller's registers
         LR    R12,R15             R12 = base register
         USING PrtTot,R12          Establish addressability
         L     R13,8(,R13)         Next save area
*
         SR    R8,R8               Accumulate # fails
         LR    R9,R8               Accumulate # succeedes
*
         LM    R3,R5,PTTests       R3 --> first test total
*                                  R4  =  len one test total
*                                  R5 --> last test total
PTLP     DS    0H
         LM    R6,R7,0(R3)         R6 --> (# fails, # succeesses)
*                                  R7 --> test number (2 chars)
         LM    R0,R1,0(R6)         R0 = # fails, R1 = # successes
         AR    R8,R0               Accumulate # fails
         AR    R9,R1               Accumulate # successes
*
         CVD   R0,PTDW             Convert to packed decimal
         MVC   PTWK,PTPATT1        Copy edit pattern to work
         ED    PTWK,PTDW+5         Edit number
         MVC   PTW1#F,PTWK+1       Copy to print line
*
         CVD   R1,PTDW             Convert to packed decimal
         MVC   PTWK,PTPATT1        Copy edit pattern to work
         ED    PTWK,PTDW+5         Edit number
         MVC   PTW1#P,PTWK+1       Copy to print line
*
         MVC   PTW1T#,0(R7)        Copy test number to print line
*
         WTO   MF=(E,PTWTO1)       Show subtotal line
*
         BXLE  R3,R4,PTLP          Show all subtotals
*
         WTO   MF=(E,PTWTO2)       Lines under subtotals
*
         CVD   R8,PTDW             Convert to packed decimal
         MVC   PTWK,PTPATT1        Copy edit pattern to work
         ED    PTWK,PTDW+5         Edit number
         MVC   PTW3#F,PTWK+1       Copy to print line
*
         CVD   R9,PTDW             Convert to packed decimal
         MVC   PTWK,PTPATT1        Copy edit pattern to work
         ED    PTWK,PTDW+5         Edit number
         MVC   PTW3#P,PTWK+1       Copy to print line
*
         WTO   MF=(E,PTWTO3)       Show totals line
*
         L     R13,4(,R13)         Caller's save area
         LM    R14,R12,12(R13)     Restore caller's registers
         BR    R14                 Return to caller
*
PTTests  DC    A(PTT1,8,PTTN)      1st, len 1, last
PTT1     DS    0A                  First test totals
         DC    A(MP01ST,PTT#)
         DC    A(MP02ST,PTT#+2)
         DC    A(MP03ST,PTT#+4)
         DC    A(MP04ST,PTT#+6)
         DC    A(MP05ST,PTT#+8)
PTTN     EQU   *-8,8               Last test totals
*
PTT#     DC    C'0102030405'       2-digig literals for test numbers
*
PTDW     DS    D                   Doubleword work
PTWK     DS    CL6                 Work area for number conversion
PTPATT1  DC    X'402020202120'     Edit pattern
*
PTWTO1   WTO  'Test xx:  NumFail xxxxx  NumPass xxxxx',MF=L
PTW1T#   EQU   PTWTO1+4+5,2
PTW1#F   EQU   PTWTO1+4+18,5
PTW1#P   EQU   PTWTO1+4+33,5
*
PTWTO2   WTO  '                  -----          -----',MF=L
*
PTWTO3   WTO  'Totals:   TotFail xxxxx  TotPass xxxxx',MF=L
PTW3#F   EQU   PTWTO3+4+18,5
PTW3#P   EQU   PTWTO3+4+33,5
*
         DROP  R11,R12             End addressability
*
         TITLE 'Display CC, program mask, amode, and GPRs via WTO'
*
***********************************************************************
*
* Routine: DUMPREGS
*
* Display all 16 GPRs, addressing mode, condition code and program mask
*
* Caller restores registers
*
***********************************************************************
*
         PUSH  USING               Save USING state
         DROP  ,                   End all addressability
DUMPREGS DS    0H
         LR    12,15               Register 12 = base register
         USING DUMPREGS,12         Establish addressability
         ST    14,DRR14            Save return address
*
         MVC   XREGS,0(1)          Copy registers
         MVC   XCCPM,128(1)        Copy CC, program mask
*
         UNPK  DW2(3),XCCPM(2)     Convert CC and program mask
         TR    DW2(2),H2P          ... to printable hex
         MVC   W2CCPM,DW2          Copy to WTO
*
         TAM   ,                   Get current amode
         BC    B'1000',DRA24       24-bit mode
         BC    B'0100',DRA31       31-bit mode
         MVC   W2AMODE,DRAM64      64-bit mode: copy literal to WTO
         B     DRAX                Continue
DRA24    DS    0H
         MVC   W2AMODE,DRAM24      Copy literal to WTO
         B     DRAX                Continue
DRA31    DS    0H
         MVC   W2AMODE,DRAM31      Copy literal to WTO
*NSI     B     DRAX                Continue
DRAX     DS    0H
*
         WTO   MF=(E,WTOCC)        Dump CC and program mask
*
         LA    3,XREGS             Beginning of register area
         LA    8,XREGS+L'XREGS-1   Last byte of register area
         LA    6,WTOLIT1-L'WTOLIT1 Before first literal
DRLP1    DS    0H                  One line
         LA    6,L'WTOLIT(,6)      Next literal
         MVC   WTOLIT,0(6)         Copy literal for line
         LA    7,WTOR1             First register on output line
         LA    5,4*8(,3)           Past group of 4 registers
DRLP2    DS    0H
         UNPK  DW2(9),0(5,3)       Convert one register
         UNPK  DW2+8(9),4(5,3)     ... to printable hex
         TR    DW2(16),H2P         Finish conversion
         MVC   0(16,7),DW2         Copy to WTO
         LA    7,L'WTOR1+1(,7)     Next register on output line
         LA    3,8(,3)             Next register to dump
         CR    3,5                 Finished line?
         BL    DRLP2               No; continue on line
*
         WTO   MF=(E,WTO0)         Dump one line of registers
*
         CR    5,8                 More registers?
         BL    DRLP1               Yes; do next group
*
         L     14,DRR14            Restore return address
         BR    14                  Return to caller
DRR14    DS    F                   Save return address
WTOLIT1  DS    0CL(L'WTOLIT03)     Beginning of literals for lines
WTOLIT03 DC    C'R0-R3'
WTOLIT47 DC    C'R4-R7'
WTOLIT8B DC    C'R8-RB'
WTOLITCF DC    C'RC-RF'
*
WTO0     WTO   'xxxxx  xxxxxxxxxxxxxxxx xxxxxxxxxxxxxxxx xxxxxxxxxxxxxxx
               xx xxxxxxxxxxxxxxxx',MF=L
WTOLIT   EQU   WTO0+4,5
WTOR1    EQU   WTO0+4+7,16
WTOR2    EQU   WTO0+4+24,16
WTOR3    EQU   WTO0+4+41,16
WTOR4    EQU   WTO0+4+58,16
*
WTOCC    WTO   'CCPM   xx  AM  xx',MF=L
W2CCPM   EQU   WTOCC+4+7,2
W2AMODE  EQU   WTOCC+4+15,2
*
DRAM24   DC    C'24'               Amode 24 literal
DRAM31   DC    C'31'               Amode 31 literal
DRAM64   DC    C'64'               Amode 64 literal
*
DW2      DS    2D,Xl1
*
         DS    0D
         DS    F
XCCPM    DS    XL4                 Condition code and program mask
XREGS    DS    XL128,Xl1           Registers: 0--15
*
H2P      EQU   *-240
         DC    C'0123456789ABCDEF'
*
         POP   USING               Restore USING state
***********************************************************************
         TITLE 'Data area'
*
         USING Data,R11            R11 --> Data always
Data     DS    0D
***********************************************************************
*        Save areas: 8 pre-chained
***********************************************************************
SA       DS    0D
SA1      DC    18F'0'              Save area
         ORG   SA1+4
         DC    A(0,SA2)
         ORG   ,
SA2      DC    18F'0'              Save area
         ORG   SA2+4
         DC    A(SA1,SA3)
         ORG   ,
SA3      DC    18F'0'              Save area
         ORG   SA3+4
         DC    A(SA2,SA4)
         ORG   ,
SA4      DC    18F'0'              Save area
         ORG   SA4+4
         DC    A(SA3,SA5)
         ORG   ,
SA5      DC    18F'0'              Save area
         ORG   SA5+4
         DC    A(SA4,SA6)
         ORG   ,
SA6      DC    18F'0'              Save area
         ORG   SA6+4
         DC    A(SA5,SA7)
         ORG   ,
SA7      DC    18F'0'              Save area
         ORG   SA7+4
         DC    A(SA6,SA8)
         ORG   ,
SA8      DC    18F'0'              Save area
         ORG   SA8+4
         DC    A(SA7,0)
         ORG   ,
*
***********************************************************************
*        ESTAE data
***********************************************************************
ESPARM   DS    0A                  Parameter list for ESTAE exit
         DC    A(ESRET@)           A(Return address for ESTAE)
         DC    A(ESCOMP)           A(Word for completion code)
         DC    A(ESFLAGS)          A(flags for ESTAE exit)
ESRET@   DC    A(0)                Return address for ESTAE
ESCOMP   DC    F'0'                Completion code from ESTAE
ESFLAGS  DS    0XL4                Flags for ESTAE exit
ESF1     DC    X'00'               Flag 1
ESF10C6  EQU   B'10000000'         Monitor S0C6
ESF10C7  EQU   B'01000000'         Monitor S0C7
ESF1DREG EQU   B'00000001'         Dump registers
         DC    XL3'00'             Reserved
***********************************************************************
*        Test subtotals: failures, successes
***********************************************************************
*
*        Subtotals for MP tests 1 -- 5
*
MP01ST   DS    0D
MP01#F   DS    F                   Number of failures
MP01#S   DS    F                   Number of successes
*
MP02ST   DS    0D
MP02#F   DS    F                   Number of failures
MP02#S   DS    F                   Number of successes
*
MP03ST   DS    0D
MP03#F   DS    F                   Number of failures
MP03#S   DS    F                   Number of successes
*
MP04ST   DS    0D
MP04#F   DS    F                   Number of failures
MP04#S   DS    F                   Number of successes
*
MP05ST   DS    0D
MP05#F   DS    F                   Number of failures
MP05#S   DS    F                   Number of successes
*
         DS    0D
***********************************************************************
*        Work fields
***********************************************************************
*
*        Values used in Print routine
*
ABCC0C6  DC    A(X'0C6')           Abend completion code S0C6
ABCC0C7  DC    A(X'0C7')           Abend completion code S0C7
*
Spaces   DC    CL32' '             32 bytes of spaces
*
WRptType DS    C                   Report type; A (all) or S (summary)
WT#      DS    C                   Test number
WErr     DS    C                   Error indicator; blank or *
         DS    XL1                 Unused; alignment
WCC      DS    F                   Condition code after execution
WResult  DS    XL16                Results copied here; left-justified
WActABCC DS    F                   Actual abend completion code
WExpABCC DS    F                   Expected abend completion code
*
*        Work fields for packed decimal instructions
*
 ago .jg100
W1L1     DS    PL1                 Packed length 1
W2L1     DS    PL1                 Packed length 1
W3L1     DS    PL1                 Packed length 1
*
W1L2     DS    PL2                 Packed length 2
W2L2     DS    PL2                 Packed length 2
W3L2     DS    PL2                 Packed length 2
*
W1L3     DS    PL3                 Packed length 3
W2L3     DS    PL3                 Packed length 3
W3L3     DS    PL3                 Packed length 3
*
W1L4     DS    PL4                 Packed length 4
W2L4     DS    PL4                 Packed length 4
W3L4     DS    PL4                 Packed length 4
*
W1L5     DS    PL5                 Packed length 5
W2L5     DS    PL5                 Packed length 5
W3L5     DS    PL5                 Packed length 5
*
W1L6     DS    PL6                 Packed length 6
W2L6     DS    PL6                 Packed length 6
W3L6     DS    PL6                 Packed length 6
*
W1L7     DS    PL7                 Packed length 7
W2L7     DS    PL7                 Packed length 7
W3L7     DS    PL7                 Packed length 7
*
W1L8     DS    PL8                 Packed length 8
W2L8     DS    PL8                 Packed length 8
W3L8     DS    PL8                 Packed length 8
*
W1L9     DS    PL9                 Packed length 9
W2L9     DS    PL9                 Packed length 9
W3L9     DS    PL9                 Packed length 9
*
W1L10    DS    PL10                Packed length 10
W2L10    DS    PL10                Packed length 10
W3L10    DS    PL10                Packed length 10
*
W1L11    DS    PL11                Packed length 11
W2L11    DS    PL11                Packed length 11
W3L11    DS    PL11                Packed length 11
*
W1L12    DS    PL12                Packed length 12
W2L12    DS    PL12                Packed length 12
W3L12    DS    PL12                Packed length 12
*
W1L13    DS    PL13                Packed length 13
W2L13    DS    PL13                Packed length 13
W3L13    DS    PL13                Packed length 13
*
W1L14    DS    PL14                Packed length 14
W2L14    DS    PL14                Packed length 14
W3L14    DS    PL14                Packed length 14
*
W1L15    DS    PL15                Packed length 15
W2L15    DS    PL15                Packed length 15
W3L15    DS    PL15                Packed length 15
*
W1L16    DS    PL16                Packed length 16
W2L16    DS    PL16                Packed length 16
W3L16    DS    PL16                Packed length 16
.jg100 anop
* ago .jg200
W1L16    DS    PL16                Packed length 16
         ORG   W1L16+1
W1L15    DS    PL15                Packed length 15
         ORG   W1L16+2
W1L14    DS    PL14                Packed length 14
         ORG   W1L16+3
W1L13    DS    PL13                Packed length 13
         ORG   W1L16+4
W1L12    DS    PL12                Packed length 12
         ORG   W1L16+5
W1L11    DS    PL11                Packed length 11
         ORG   W1L16+6
W1L10    DS    PL10                Packed length 10
         ORG   W1L16+7
W1L9     DS    PL9                 Packed length 9
         ORG   W1L16+8
W1L8     DS    PL8                 Packed length 8
         ORG   W1L16+9
W1L7     DS    PL7                 Packed length 7
         ORG   W1L16+10
W1L6     DS    PL6                 Packed length 6
         ORG   W1L16+11
W1L5     DS    PL5                 Packed length 5
         ORG   W1L16+12
W1L4     DS    PL4                 Packed length 4
         ORG   W1L16+13
W1L3     DS    PL3                 Packed length 3
         ORG   W1L16+14
W1L2     DS    PL2                 Packed length 2
         ORG   W1L16+15
W1L1     DS    PL1                 Packed length 1
         ORG   ,
*
W2L16    DS    PL16                Packed length 16
         ORG   W2L16+1
W2L15    DS    PL15                Packed length 15
         ORG   W2L16+2
W2L14    DS    PL14                Packed length 14
         ORG   W2L16+3
W2L13    DS    PL13                Packed length 13
         ORG   W2L16+4
W2L12    DS    PL12                Packed length 12
         ORG   W2L16+5
W2L11    DS    PL11                Packed length 11
         ORG   W2L16+6
W2L10    DS    PL10                Packed length 10
         ORG   W2L16+7
W2L9     DS    PL9                 Packed length 9
         ORG   W2L16+8
W2L8     DS    PL8                 Packed length 8
         ORG   W2L16+9
W2L7     DS    PL7                 Packed length 7
         ORG   W2L16+10
W2L6     DS    PL6                 Packed length 6
         ORG   W2L16+11
W2L5     DS    PL5                 Packed length 5
         ORG   W2L16+12
W2L4     DS    PL4                 Packed length 4
         ORG   W2L16+13
W2L3     DS    PL3                 Packed length 3
         ORG   W2L16+14
W2L2     DS    PL2                 Packed length 2
         ORG   W2L16+15
W2L1     DS    PL1                 Packed length 1
         ORG   ,
.jg200 anop
*
***********************************************************************
*        Report lines
***********************************************************************
*
WTOStart WTO   '***** MP instruction tests started *****',MF=L
*
WTOEnd   WTO   '***** MP instruction tests ended   *****',MF=L
*
* Line 1: length 70
*        +00(1) C test routine; 1-9
*        +01(1) space
*        +02(32) printable hex multiplicand; right-aligned
*        +34(3) " * "
*        +37(32) printable hex multiplier; left-aligned
*
* Line 2: length 90
*        +00(4) spaces
*        +04(6) spaces or "ERROR"
*        +10(6) literal "AnsExp"
*        +16(1) space
*        +17(32) printable hex expected answer; left-jusified
*        +49(2) spaces
*        +51(6) literal "AnsAct"
*        +57(1) space
*        +58(32) printable hex actual answer; left-justified
*
* Line 3: length 26
*        +00(4) spaces
*        +04(5) spaces or "ERROR"
*        +09(1) space
*        +10(5) literal "CCAct"
*        +15(1) space
*        +16(1) actual condition code; 0-3
*        +17(2) spaces
*        +19(5) literal "CCExp"
*        +24(1) space
*        +25(1) expected condition code; 3
*
* Line 4: length 44
*        +00(4) spaces
*        +04(5) spaces or "ERROR"
*        +09(1) space
*        +10(7) literal "ABCCAct"
*        +17(1) space
*        +18(8) actual abend completion code; fullword
*        +26(2) spaces
*        +28(7) literal "ABCCExp"
*        +35(1) space
*        +36(8) expected abend completion code; fullword
*
WTO1     WTO   'xx xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx * xxxxxxxxxxxxxxxxxx
               xxxxxxxxxxxxxxx',MF=L
WT01Len  EQU   *-WTO1-4
*
W1T#     EQU   WTO1+4,1
W1Err    EQU   WTO1+4+1,1
W1Mpcnd  EQU   WTO1+4+3,32
W1Mplr   EQU   WTO1+4+38,32
*
WTO2     WTO   '    xxxxx AnsAct xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx  AnsEx
               xp xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',MF=L
WTO2Len  EQU   *-WTO2-4
*
W2ELit   EQU   WTO2+4+4,5
W2AAns   EQU   WTO2+4+17,32
W2EAns   EQU   WTO2+4+58,32
*
WTO3     WTO   '    xxxxx CCAct x  CCExp x',MF=L
WTO3Len  EQU   *-WTO3-4
*
W3ELit   EQU   WTO3+4+4,5
W3ACC    EQU   WTO3+4+16,1
W3ECC    EQU   WTO3+4+25,1
*
WTO4     WTO   '    xxxxx ABCCAct xxxxxxxx  ABCCExp xxxxxxxx',MF=L
WTO4Len  EQU   *-WTO4-4
*
W4ELit   EQU   WTO4+4+4,5
W4AABCC  EQU   WTO4+4+18,8
W4EABCC  EQU   WTO4+4+36,8
*
DW       DS    4D,XL1              Work doublewords, pad
*
WK16     DS    XL16,XL1            Work area for number conversion, pad
*
H2P2     EQU   *-240               Convert to printable hex
         DC    C'0123456789ABCDEF'
*       
         DS    0D                                            
***********************************************************************
*        End data
***********************************************************************
         DROP  R11                 End data area overlay
***********************************************************************
         EQUREGS ,
***********************************************************************
         IHASDWA ,                 DSECT for SDWA
*                                                                 
         END   TMP
